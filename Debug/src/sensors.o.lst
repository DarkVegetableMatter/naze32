   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"sensors.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	calibratingA
  19              		.bss
  20              		.align	1
  23              	calibratingA:
  24 0000 0000     		.space	2
  25              		.global	calibratingB
  26              		.align	1
  29              	calibratingB:
  30 0002 0000     		.space	2
  31              		.global	calibratingG
  32              		.align	1
  35              	calibratingG:
  36 0004 0000     		.space	2
  37              		.global	acc_1G
  38              		.data
  39              		.align	1
  42              	acc_1G:
  43 0000 0001     		.short	256
  44              		.comm	heading,2,2
  45              		.comm	magHold,2,2
  46              		.comm	acc,20,4
  47              		.comm	gyro,20,4
  48              		.comm	baro,24,4
  49              		.global	accHardware
  50              		.bss
  53              	accHardware:
  54 0006 00       		.space	1
  55              		.global	__aeabi_i2f
  56              		.global	__aeabi_fmul
  57              		.global	__aeabi_fadd
  58              		.text
  59              		.align	2
  60              		.global	sensorsAutodetect
  61              		.thumb
  62              		.thumb_func
  64              	sensorsAutodetect:
  65              	.LFB29:
  66              		.file 1 "../src/sensors.c"
   1:../src/sensors.c **** #include "board.h"
   2:../src/sensors.c **** #include "mw.h"
   3:../src/sensors.c **** 
   4:../src/sensors.c **** uint16_t calibratingA = 0;      // the calibration is done is the main loop. Calibrating decreases 
   5:../src/sensors.c **** uint16_t calibratingB = 0;      // baro calibration = get new ground pressure value
   6:../src/sensors.c **** uint16_t calibratingG = 0;
   7:../src/sensors.c **** uint16_t acc_1G = 256;          // this is the 1G measured acceleration.
   8:../src/sensors.c **** int16_t heading, magHold;
   9:../src/sensors.c **** 
  10:../src/sensors.c **** extern uint16_t InflightcalibratingA;
  11:../src/sensors.c **** extern int16_t AccInflightCalibrationArmed;
  12:../src/sensors.c **** extern uint16_t AccInflightCalibrationMeasurementDone;
  13:../src/sensors.c **** extern uint16_t AccInflightCalibrationSavetoEEProm;
  14:../src/sensors.c **** extern uint16_t AccInflightCalibrationActive;
  15:../src/sensors.c **** extern uint16_t batteryWarningVoltage;
  16:../src/sensors.c **** extern uint8_t batteryCellCount;
  17:../src/sensors.c **** extern float magneticDeclination;
  18:../src/sensors.c **** 
  19:../src/sensors.c **** sensor_t acc;                       // acc access functions
  20:../src/sensors.c **** sensor_t gyro;                      // gyro access functions
  21:../src/sensors.c **** baro_t baro;                        // barometer access functions
  22:../src/sensors.c **** uint8_t accHardware = ACC_DEFAULT;  // which accel chip is used/detected
  23:../src/sensors.c **** 
  24:../src/sensors.c **** #ifdef FY90Q
  25:../src/sensors.c **** // FY90Q analog gyro/acc
  26:../src/sensors.c **** void sensorsAutodetect(void)
  27:../src/sensors.c **** {
  28:../src/sensors.c ****     adcSensorInit(&acc, &gyro);
  29:../src/sensors.c **** }
  30:../src/sensors.c **** #else
  31:../src/sensors.c **** // AfroFlight32 i2c sensors
  32:../src/sensors.c **** void sensorsAutodetect(void)
  33:../src/sensors.c **** {
  67              		.loc 1 33 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 16
  70              		@ frame_needed = 1, uses_anonymous_args = 0
  71 0000 90B5     		push	{r4, r7, lr}
  72              	.LCFI0:
  73              		.cfi_def_cfa_offset 12
  74              		.cfi_offset 4, -12
  75              		.cfi_offset 7, -8
  76              		.cfi_offset 14, -4
  77 0002 85B0     		sub	sp, sp, #20
  78              	.LCFI1:
  79              		.cfi_def_cfa_offset 32
  80 0004 00AF     		add	r7, sp, #0
  81              	.LCFI2:
  82              		.cfi_def_cfa_register 7
  34:../src/sensors.c ****     int16_t deg, min;
  35:../src/sensors.c ****     drv_adxl345_config_t acc_params;
  36:../src/sensors.c ****     bool haveMpu6k = false;
  83              		.loc 1 36 0
  84 0006 4FF00003 		mov	r3, #0
  85 000a FB73     		strb	r3, [r7, #15]
  37:../src/sensors.c **** 
  38:../src/sensors.c ****     // Autodetect gyro hardware. We have MPU3050 or MPU6050.
  39:../src/sensors.c ****     if (mpu6050Detect(&acc, &gyro, mcfg.gyro_lpf, &mcfg.mpu6050_scale)) {
  86              		.loc 1 39 0
  87 000c 7D4B     		ldr	r3, .L17
  88 000e B3F8E430 		ldrh	r3, [r3, #228]
  89 0012 7D48     		ldr	r0, .L17+4
  90 0014 7D49     		ldr	r1, .L17+8
  91 0016 1A46     		mov	r2, r3
  92 0018 7D4B     		ldr	r3, .L17+12
  93 001a FFF7FEFF 		bl	mpu6050Detect
  94 001e 0346     		mov	r3, r0
  95 0020 002B     		cmp	r3, #0
  96 0022 03D0     		beq	.L2
  40:../src/sensors.c ****         // this filled up  acc.* struct with init values
  41:../src/sensors.c ****         haveMpu6k = true;
  97              		.loc 1 41 0
  98 0024 4FF00103 		mov	r3, #1
  99 0028 FB73     		strb	r3, [r7, #15]
 100 002a 1AE0     		b	.L3
 101              	.L2:
  42:../src/sensors.c ****     } else if (l3g4200dDetect(&gyro, mcfg.gyro_lpf)) {
 102              		.loc 1 42 0
 103 002c 754B     		ldr	r3, .L17
 104 002e B3F8E430 		ldrh	r3, [r3, #228]
 105 0032 7648     		ldr	r0, .L17+8
 106 0034 1946     		mov	r1, r3
 107 0036 FFF7FEFF 		bl	l3g4200dDetect
 108 003a 0346     		mov	r3, r0
 109 003c 002B     		cmp	r3, #0
 110 003e 10D1     		bne	.L3
  43:../src/sensors.c ****         // well, we found our gyro
  44:../src/sensors.c ****         ;
  45:../src/sensors.c ****     } else if (!mpu3050Detect(&gyro, mcfg.gyro_lpf)) {
 111              		.loc 1 45 0
 112 0040 704B     		ldr	r3, .L17
 113 0042 B3F8E430 		ldrh	r3, [r3, #228]
 114 0046 7148     		ldr	r0, .L17+8
 115 0048 1946     		mov	r1, r3
 116 004a FFF7FEFF 		bl	mpu3050Detect
 117 004e 0346     		mov	r3, r0
 118 0050 83F00103 		eor	r3, r3, #1
 119 0054 DBB2     		uxtb	r3, r3
 120 0056 002B     		cmp	r3, #0
 121 0058 03D0     		beq	.L3
  46:../src/sensors.c ****         // if this fails, we get a beep + blink pattern. we're doomed, no gyro or i2c error.
  47:../src/sensors.c ****         failureMode(3);
 122              		.loc 1 47 0
 123 005a 4FF00300 		mov	r0, #3
 124 005e FFF7FEFF 		bl	failureMode
 125              	.L3:
  48:../src/sensors.c ****     }
  49:../src/sensors.c **** 
  50:../src/sensors.c ****     // Accelerometer. Fuck it. Let user break shit.
  51:../src/sensors.c **** retry:
  52:../src/sensors.c ****     switch (mcfg.acc_hardware) {
 126              		.loc 1 52 0
 127 0062 684B     		ldr	r3, .L17
 128 0064 93F8E330 		ldrb	r3, [r3, #227]	@ zero_extendqisi2
 129 0068 032B     		cmp	r3, #3
 130 006a 4AD8     		bhi	.L4
 131 006c 01A1     		adr	r1, .L8
 132 006e 51F823F0 		ldr	pc, [r1, r3, lsl #2]
 133 0072 00BF     		.align	2
 134              	.L8:
 135 0074 85000000 		.word	.L5+1
 136 0078 85000000 		.word	.L5+1
 137 007c B5000000 		.word	.L6+1
 138 0080 DF000000 		.word	.L7+1
 139              	.L5:
  53:../src/sensors.c ****         case 0: // autodetect
  54:../src/sensors.c ****         case 1: // ADXL345
  55:../src/sensors.c ****             acc_params.useFifo = false;
 140              		.loc 1 55 0
 141 0084 4FF00003 		mov	r3, #0
 142 0088 3B71     		strb	r3, [r7, #4]
  56:../src/sensors.c ****             acc_params.dataRate = 800; // unused currently
 143              		.loc 1 56 0
 144 008a 4FF44873 		mov	r3, #800
 145 008e FB80     		strh	r3, [r7, #6]	@ movhi
  57:../src/sensors.c ****             if (adxl345Detect(&acc_params, &acc))
 146              		.loc 1 57 0
 147 0090 07F10403 		add	r3, r7, #4
 148 0094 1846     		mov	r0, r3
 149 0096 5C49     		ldr	r1, .L17+4
 150 0098 FFF7FEFF 		bl	adxl345Detect
 151 009c 0346     		mov	r3, r0
 152 009e 002B     		cmp	r3, #0
 153 00a0 03D0     		beq	.L9
  58:../src/sensors.c ****                 accHardware = ACC_ADXL345;
 154              		.loc 1 58 0
 155 00a2 5C4B     		ldr	r3, .L17+16
 156 00a4 4FF00102 		mov	r2, #1
 157 00a8 1A70     		strb	r2, [r3, #0]
 158              	.L9:
  59:../src/sensors.c ****             if (mcfg.acc_hardware == ACC_ADXL345)
 159              		.loc 1 59 0
 160 00aa 564B     		ldr	r3, .L17
 161 00ac 93F8E330 		ldrb	r3, [r3, #227]	@ zero_extendqisi2
 162 00b0 012B     		cmp	r3, #1
 163 00b2 23D0     		beq	.L15
 164              	.L6:
  60:../src/sensors.c ****                 break;
  61:../src/sensors.c ****             ; // fallthrough
  62:../src/sensors.c ****         case 2: // MPU6050
  63:../src/sensors.c ****             if (haveMpu6k) {
 165              		.loc 1 63 0
 166 00b4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 167 00b6 002B     		cmp	r3, #0
 168 00b8 11D0     		beq	.L7
  64:../src/sensors.c ****                 mpu6050Detect(&acc, &gyro, mcfg.gyro_lpf, &mcfg.mpu6050_scale); // yes, i'm rerunni
 169              		.loc 1 64 0
 170 00ba 524B     		ldr	r3, .L17
 171 00bc B3F8E430 		ldrh	r3, [r3, #228]
 172 00c0 5148     		ldr	r0, .L17+4
 173 00c2 5249     		ldr	r1, .L17+8
 174 00c4 1A46     		mov	r2, r3
 175 00c6 524B     		ldr	r3, .L17+12
 176 00c8 FFF7FEFF 		bl	mpu6050Detect
  65:../src/sensors.c ****                 accHardware = ACC_MPU6050;
 177              		.loc 1 65 0
 178 00cc 514B     		ldr	r3, .L17+16
 179 00ce 4FF00202 		mov	r2, #2
 180 00d2 1A70     		strb	r2, [r3, #0]
  66:../src/sensors.c ****                 if (mcfg.acc_hardware == ACC_MPU6050)
 181              		.loc 1 66 0
 182 00d4 4B4B     		ldr	r3, .L17
 183 00d6 93F8E330 		ldrb	r3, [r3, #227]	@ zero_extendqisi2
 184 00da 022B     		cmp	r3, #2
 185 00dc 10D0     		beq	.L16
 186              	.L7:
  67:../src/sensors.c ****                     break;
  68:../src/sensors.c ****             }
  69:../src/sensors.c ****             ; // fallthrough
  70:../src/sensors.c ****         case 3: // MMA8452
  71:../src/sensors.c **** #ifndef OLIMEXINO
  72:../src/sensors.c ****             if (mma8452Detect(&acc)) {
 187              		.loc 1 72 0
 188 00de 4A48     		ldr	r0, .L17+4
 189 00e0 FFF7FEFF 		bl	mma8452Detect
 190 00e4 0346     		mov	r3, r0
 191 00e6 002B     		cmp	r3, #0
 192 00e8 0BD0     		beq	.L4
  73:../src/sensors.c ****                 accHardware = ACC_MMA8452;
 193              		.loc 1 73 0
 194 00ea 4A4B     		ldr	r3, .L17+16
 195 00ec 4FF00302 		mov	r2, #3
 196 00f0 1A70     		strb	r2, [r3, #0]
  74:../src/sensors.c ****                 if (mcfg.acc_hardware == ACC_MMA8452)
 197              		.loc 1 74 0
 198 00f2 444B     		ldr	r3, .L17
 199 00f4 93F8E330 		ldrb	r3, [r3, #227]	@ zero_extendqisi2
 200 00f8 032B     		cmp	r3, #3
 201 00fa 02E0     		b	.L4
 202              	.L15:
  60:../src/sensors.c ****                 break;
 203              		.loc 1 60 0
 204 00fc 00BF     		nop
 205 00fe 00E0     		b	.L4
 206              	.L16:
  67:../src/sensors.c ****                     break;
 207              		.loc 1 67 0
 208 0100 00BF     		nop
 209              	.L4:
  75:../src/sensors.c ****                     break;
  76:../src/sensors.c ****             }
  77:../src/sensors.c **** #endif
  78:../src/sensors.c ****     }
  79:../src/sensors.c **** 
  80:../src/sensors.c ****     // Found anything? Check if user fucked up or ACC is really missing.
  81:../src/sensors.c ****     if (accHardware == ACC_DEFAULT) {
 210              		.loc 1 81 0
 211 0102 444B     		ldr	r3, .L17+16
 212 0104 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 213 0106 002B     		cmp	r3, #0
 214 0108 0ED1     		bne	.L10
  82:../src/sensors.c ****         if (mcfg.acc_hardware > ACC_DEFAULT) {
 215              		.loc 1 82 0
 216 010a 3E4B     		ldr	r3, .L17
 217 010c 93F8E330 		ldrb	r3, [r3, #227]	@ zero_extendqisi2
 218 0110 002B     		cmp	r3, #0
 219 0112 05D0     		beq	.L11
  83:../src/sensors.c ****             // Nothing was found and we have a forced sensor type. Stupid user probably chose a sen
  84:../src/sensors.c ****             mcfg.acc_hardware = ACC_DEFAULT;
 220              		.loc 1 84 0
 221 0114 3B4B     		ldr	r3, .L17
 222 0116 4FF00002 		mov	r2, #0
 223 011a 83F8E320 		strb	r2, [r3, #227]
  85:../src/sensors.c ****             goto retry;
 224              		.loc 1 85 0
 225 011e A0E7     		b	.L3
 226              	.L11:
  86:../src/sensors.c ****         } else {
  87:../src/sensors.c ****             // We're really screwed
  88:../src/sensors.c ****             sensorsClear(SENSOR_ACC);
 227              		.loc 1 88 0
 228 0120 4FF00100 		mov	r0, #1
 229 0124 FFF7FEFF 		bl	sensorsClear
 230              	.L10:
  89:../src/sensors.c ****         }
  90:../src/sensors.c ****     }
  91:../src/sensors.c **** 
  92:../src/sensors.c **** #ifdef BARO
  93:../src/sensors.c ****     // Detect what pressure sensors are available. baro->update() is set to sensor-specific update 
  94:../src/sensors.c ****     if (!ms5611Detect(&baro)) {
 231              		.loc 1 94 0
 232 0128 3B48     		ldr	r0, .L17+20
 233 012a FFF7FEFF 		bl	ms5611Detect
 234 012e 0346     		mov	r3, r0
 235 0130 83F00103 		eor	r3, r3, #1
 236 0134 DBB2     		uxtb	r3, r3
 237 0136 002B     		cmp	r3, #0
 238 0138 0CD0     		beq	.L12
  95:../src/sensors.c ****         // ms5611 disables BMP085, and tries to initialize + check PROM crc. if this works, we have
  96:../src/sensors.c ****         if (!bmp085Detect(&baro)) {
 239              		.loc 1 96 0
 240 013a 3748     		ldr	r0, .L17+20
 241 013c FFF7FEFF 		bl	bmp085Detect
 242 0140 0346     		mov	r3, r0
 243 0142 83F00103 		eor	r3, r3, #1
 244 0146 DBB2     		uxtb	r3, r3
 245 0148 002B     		cmp	r3, #0
 246 014a 03D0     		beq	.L12
  97:../src/sensors.c ****             // if both failed, we don't have anything
  98:../src/sensors.c ****             sensorsClear(SENSOR_BARO);
 247              		.loc 1 98 0
 248 014c 4FF00200 		mov	r0, #2
 249 0150 FFF7FEFF 		bl	sensorsClear
 250              	.L12:
  99:../src/sensors.c ****         }
 100:../src/sensors.c ****     }
 101:../src/sensors.c **** #endif
 102:../src/sensors.c **** 
 103:../src/sensors.c ****     // Now time to init things, acc first
 104:../src/sensors.c ****     if (sensors(SENSOR_ACC))
 251              		.loc 1 104 0
 252 0154 4FF00100 		mov	r0, #1
 253 0158 FFF7FEFF 		bl	sensors
 254 015c 0346     		mov	r3, r0
 255 015e 002B     		cmp	r3, #0
 256 0160 02D0     		beq	.L13
 105:../src/sensors.c ****         acc.init();
 257              		.loc 1 105 0
 258 0162 294B     		ldr	r3, .L17+4
 259 0164 1B68     		ldr	r3, [r3, #0]
 260 0166 9847     		blx	r3
 261              	.L13:
 106:../src/sensors.c ****     // this is safe because either mpu6050 or mpu3050 or lg3d20 sets it, and in case of fail, we ne
 107:../src/sensors.c ****     gyro.init();
 262              		.loc 1 107 0
 263 0168 284B     		ldr	r3, .L17+8
 264 016a 1B68     		ldr	r3, [r3, #0]
 265 016c 9847     		blx	r3
 108:../src/sensors.c **** 
 109:../src/sensors.c **** #ifdef MAG
 110:../src/sensors.c ****     if (!hmc5883lDetect())
 266              		.loc 1 110 0
 267 016e FFF7FEFF 		bl	hmc5883lDetect
 268 0172 0346     		mov	r3, r0
 269 0174 83F00103 		eor	r3, r3, #1
 270 0178 DBB2     		uxtb	r3, r3
 271 017a 002B     		cmp	r3, #0
 272 017c 03D0     		beq	.L14
 111:../src/sensors.c ****         sensorsClear(SENSOR_MAG);
 273              		.loc 1 111 0
 274 017e 4FF00400 		mov	r0, #4
 275 0182 FFF7FEFF 		bl	sensorsClear
 276              	.L14:
 112:../src/sensors.c **** #endif
 113:../src/sensors.c **** 
 114:../src/sensors.c ****     // calculate magnetic declination
 115:../src/sensors.c ****     deg = cfg.mag_declination / 100;
 277              		.loc 1 115 0
 278 0186 254B     		ldr	r3, .L17+24
 279 0188 DB8C     		ldrh	r3, [r3, #38]
 280 018a 1BB2     		sxth	r3, r3
 281 018c 244A     		ldr	r2, .L17+28
 282 018e 82FB0312 		smull	r1, r2, r2, r3
 283 0192 4FEA6212 		asr	r2, r2, #5
 284 0196 4FEAE373 		asr	r3, r3, #31
 285 019a D31A     		subs	r3, r2, r3
 286 019c BB81     		strh	r3, [r7, #12]	@ movhi
 116:../src/sensors.c ****     min = cfg.mag_declination % 100;
 287              		.loc 1 116 0
 288 019e 1F4B     		ldr	r3, .L17+24
 289 01a0 DB8C     		ldrh	r3, [r3, #38]
 290 01a2 1BB2     		sxth	r3, r3
 291 01a4 1E4A     		ldr	r2, .L17+28
 292 01a6 82FB0312 		smull	r1, r2, r2, r3
 293 01aa 4FEA6211 		asr	r1, r2, #5
 294 01ae 4FEAE372 		asr	r2, r3, #31
 295 01b2 8A1A     		subs	r2, r1, r2
 296 01b4 4FF06401 		mov	r1, #100
 297 01b8 01FB02F2 		mul	r2, r1, r2
 298 01bc 9B1A     		subs	r3, r3, r2
 299 01be 7B81     		strh	r3, [r7, #10]	@ movhi
 117:../src/sensors.c ****     magneticDeclination = (deg + ((float)min * (1.0f / 60.0f))) * 10; // heading is in 0.1deg units
 300              		.loc 1 117 0
 301 01c0 B7F90C30 		ldrsh	r3, [r7, #12]
 302 01c4 1846     		mov	r0, r3
 303 01c6 FFF7FEFF 		bl	__aeabi_i2f
 304 01ca 0446     		mov	r4, r0
 305 01cc B7F90A30 		ldrsh	r3, [r7, #10]
 306 01d0 1846     		mov	r0, r3
 307 01d2 FFF7FEFF 		bl	__aeabi_i2f
 308 01d6 0346     		mov	r3, r0
 309 01d8 1846     		mov	r0, r3
 310 01da 1349     		ldr	r1, .L17+36	@ float
 311 01dc FFF7FEFF 		bl	__aeabi_fmul
 312 01e0 0346     		mov	r3, r0
 313 01e2 2046     		mov	r0, r4
 314 01e4 1946     		mov	r1, r3
 315 01e6 FFF7FEFF 		bl	__aeabi_fadd
 316 01ea 0346     		mov	r3, r0
 317 01ec 1846     		mov	r0, r3
 318 01ee 0F49     		ldr	r1, .L17+40	@ float
 319 01f0 FFF7FEFF 		bl	__aeabi_fmul
 320 01f4 0346     		mov	r3, r0
 321 01f6 1A46     		mov	r2, r3
 322 01f8 0A4B     		ldr	r3, .L17+32
 323 01fa 1A60     		str	r2, [r3, #0]	@ float
 118:../src/sensors.c **** }
 324              		.loc 1 118 0
 325 01fc 07F11407 		add	r7, r7, #20
 326 0200 BD46     		mov	sp, r7
 327 0202 90BD     		pop	{r4, r7, pc}
 328              	.L18:
 329              		.align	2
 330              	.L17:
 331 0204 00000000 		.word	mcfg
 332 0208 00000000 		.word	acc
 333 020c 00000000 		.word	gyro
 334 0210 ED000000 		.word	mcfg+237
 335 0214 00000000 		.word	accHardware
 336 0218 00000000 		.word	baro
 337 021c 00000000 		.word	cfg
 338 0220 1F85EB51 		.word	1374389535
 339 0224 00000000 		.word	magneticDeclination
 340 0228 8988883C 		.word	1015580809
 341 022c 00002041 		.word	1092616192
 342              		.cfi_endproc
 343              	.LFE29:
 345              		.global	__aeabi_fdiv
 346              		.global	__aeabi_f2uiz
 347              		.align	2
 348              		.global	batteryAdcToVoltage
 349              		.thumb
 350              		.thumb_func
 352              	batteryAdcToVoltage:
 353              	.LFB30:
 119:../src/sensors.c **** #endif
 120:../src/sensors.c **** 
 121:../src/sensors.c **** uint16_t batteryAdcToVoltage(uint16_t src)
 122:../src/sensors.c **** {
 354              		.loc 1 122 0
 355              		.cfi_startproc
 356              		@ args = 0, pretend = 0, frame = 8
 357              		@ frame_needed = 1, uses_anonymous_args = 0
 358 0230 90B5     		push	{r4, r7, lr}
 359              	.LCFI3:
 360              		.cfi_def_cfa_offset 12
 361              		.cfi_offset 4, -12
 362              		.cfi_offset 7, -8
 363              		.cfi_offset 14, -4
 364 0232 83B0     		sub	sp, sp, #12
 365              	.LCFI4:
 366              		.cfi_def_cfa_offset 24
 367 0234 00AF     		add	r7, sp, #0
 368              	.LCFI5:
 369              		.cfi_def_cfa_register 7
 370 0236 0346     		mov	r3, r0
 371 0238 FB80     		strh	r3, [r7, #6]	@ movhi
 123:../src/sensors.c ****     // calculate battery voltage based on ADC reading
 124:../src/sensors.c ****     // result is Vbatt in 0.1V steps. 3.3V = ADC Vref, 4095 = 12bit adc, 110 = 11:1 voltage divider
 125:../src/sensors.c ****     return (((src) * 3.3f) / 4095) * mcfg.vbatscale;
 372              		.loc 1 125 0
 373 023a FB88     		ldrh	r3, [r7, #6]
 374 023c 1846     		mov	r0, r3
 375 023e FFF7FEFF 		bl	__aeabi_i2f
 376 0242 0346     		mov	r3, r0
 377 0244 1846     		mov	r0, r3
 378 0246 1149     		ldr	r1, .L21+4	@ float
 379 0248 FFF7FEFF 		bl	__aeabi_fmul
 380 024c 0346     		mov	r3, r0
 381 024e 1846     		mov	r0, r3
 382 0250 0F49     		ldr	r1, .L21+8	@ float
 383 0252 FFF7FEFF 		bl	__aeabi_fdiv
 384 0256 0346     		mov	r3, r0
 385 0258 1C46     		mov	r4, r3
 386 025a 0B4B     		ldr	r3, .L21
 387 025c 93F8FA30 		ldrb	r3, [r3, #250]	@ zero_extendqisi2
 388 0260 1846     		mov	r0, r3
 389 0262 FFF7FEFF 		bl	__aeabi_i2f
 390 0266 0346     		mov	r3, r0
 391 0268 2046     		mov	r0, r4
 392 026a 1946     		mov	r1, r3
 393 026c FFF7FEFF 		bl	__aeabi_fmul
 394 0270 0346     		mov	r3, r0
 395 0272 1846     		mov	r0, r3
 396 0274 FFF7FEFF 		bl	__aeabi_f2uiz
 397 0278 0346     		mov	r3, r0
 398 027a 9BB2     		uxth	r3, r3
 126:../src/sensors.c **** }
 399              		.loc 1 126 0
 400 027c 1846     		mov	r0, r3
 401 027e 07F10C07 		add	r7, r7, #12
 402 0282 BD46     		mov	sp, r7
 403 0284 90BD     		pop	{r4, r7, pc}
 404              	.L22:
 405 0286 00BF     		.align	2
 406              	.L21:
 407 0288 00000000 		.word	mcfg
 408 028c 33335340 		.word	1079194419
 409 0290 00F07F45 		.word	1166012416
 410              		.cfi_endproc
 411              	.LFE30:
 413              		.align	2
 414              		.global	batteryInit
 415              		.thumb
 416              		.thumb_func
 418              	batteryInit:
 419              	.LFB31:
 127:../src/sensors.c **** 
 128:../src/sensors.c **** void batteryInit(void)
 129:../src/sensors.c **** {
 420              		.loc 1 129 0
 421              		.cfi_startproc
 422              		@ args = 0, pretend = 0, frame = 8
 423              		@ frame_needed = 1, uses_anonymous_args = 0
 424 0294 80B5     		push	{r7, lr}
 425              	.LCFI6:
 426              		.cfi_def_cfa_offset 8
 427              		.cfi_offset 7, -8
 428              		.cfi_offset 14, -4
 429 0296 82B0     		sub	sp, sp, #8
 430              	.LCFI7:
 431              		.cfi_def_cfa_offset 16
 432 0298 00AF     		add	r7, sp, #0
 433              	.LCFI8:
 434              		.cfi_def_cfa_register 7
 130:../src/sensors.c ****     uint32_t i;
 131:../src/sensors.c ****     uint32_t voltage = 0;
 435              		.loc 1 131 0
 436 029a 4FF00003 		mov	r3, #0
 437 029e 3B60     		str	r3, [r7, #0]
 132:../src/sensors.c **** 
 133:../src/sensors.c ****     // average up some voltage readings
 134:../src/sensors.c ****     for (i = 0; i < 32; i++) {
 438              		.loc 1 134 0
 439 02a0 4FF00003 		mov	r3, #0
 440 02a4 7B60     		str	r3, [r7, #4]
 441 02a6 0FE0     		b	.L24
 442              	.L25:
 135:../src/sensors.c ****         voltage += adcGetChannel(ADC_BATTERY);
 443              		.loc 1 135 0 discriminator 2
 444 02a8 4FF00000 		mov	r0, #0
 445 02ac FFF7FEFF 		bl	adcGetChannel
 446 02b0 0346     		mov	r3, r0
 447 02b2 3A68     		ldr	r2, [r7, #0]
 448 02b4 D318     		adds	r3, r2, r3
 449 02b6 3B60     		str	r3, [r7, #0]
 136:../src/sensors.c ****         delay(10);
 450              		.loc 1 136 0 discriminator 2
 451 02b8 4FF00A00 		mov	r0, #10
 452 02bc FFF7FEFF 		bl	delay
 134:../src/sensors.c ****     for (i = 0; i < 32; i++) {
 453              		.loc 1 134 0 discriminator 2
 454 02c0 7B68     		ldr	r3, [r7, #4]
 455 02c2 03F10103 		add	r3, r3, #1
 456 02c6 7B60     		str	r3, [r7, #4]
 457              	.L24:
 134:../src/sensors.c ****     for (i = 0; i < 32; i++) {
 458              		.loc 1 134 0 is_stmt 0 discriminator 1
 459 02c8 7B68     		ldr	r3, [r7, #4]
 460 02ca 1F2B     		cmp	r3, #31
 461 02cc ECD9     		bls	.L25
 137:../src/sensors.c ****     }
 138:../src/sensors.c **** 
 139:../src/sensors.c ****     voltage = batteryAdcToVoltage((uint16_t)(voltage / 32));
 462              		.loc 1 139 0 is_stmt 1
 463 02ce 3B68     		ldr	r3, [r7, #0]
 464 02d0 4FEA5313 		lsr	r3, r3, #5
 465 02d4 9BB2     		uxth	r3, r3
 466 02d6 1846     		mov	r0, r3
 467 02d8 FFF7FEFF 		bl	batteryAdcToVoltage
 468 02dc 0346     		mov	r3, r0
 469 02de 3B60     		str	r3, [r7, #0]
 140:../src/sensors.c **** 
 141:../src/sensors.c ****     // autodetect cell count, going from 2S..6S
 142:../src/sensors.c ****     for (i = 2; i < 6; i++) {
 470              		.loc 1 142 0
 471 02e0 4FF00203 		mov	r3, #2
 472 02e4 7B60     		str	r3, [r7, #4]
 473 02e6 0CE0     		b	.L26
 474              	.L29:
 143:../src/sensors.c ****         if (voltage < i * mcfg.vbatmaxcellvoltage)
 475              		.loc 1 143 0
 476 02e8 114B     		ldr	r3, .L31
 477 02ea 93F8FB30 		ldrb	r3, [r3, #251]	@ zero_extendqisi2
 478 02ee 7A68     		ldr	r2, [r7, #4]
 479 02f0 02FB03F2 		mul	r2, r2, r3
 480 02f4 3B68     		ldr	r3, [r7, #0]
 481 02f6 9A42     		cmp	r2, r3
 482 02f8 07D8     		bhi	.L30
 483              	.L27:
 142:../src/sensors.c ****     for (i = 2; i < 6; i++) {
 484              		.loc 1 142 0
 485 02fa 7B68     		ldr	r3, [r7, #4]
 486 02fc 03F10103 		add	r3, r3, #1
 487 0300 7B60     		str	r3, [r7, #4]
 488              	.L26:
 142:../src/sensors.c ****     for (i = 2; i < 6; i++) {
 489              		.loc 1 142 0 is_stmt 0 discriminator 1
 490 0302 7B68     		ldr	r3, [r7, #4]
 491 0304 052B     		cmp	r3, #5
 492 0306 EFD9     		bls	.L29
 493 0308 00E0     		b	.L28
 494              	.L30:
 144:../src/sensors.c ****             break;
 495              		.loc 1 144 0 is_stmt 1
 496 030a 00BF     		nop
 497              	.L28:
 145:../src/sensors.c ****     }
 146:../src/sensors.c ****     batteryCellCount = i;
 498              		.loc 1 146 0
 499 030c 7B68     		ldr	r3, [r7, #4]
 500 030e DAB2     		uxtb	r2, r3
 501 0310 084B     		ldr	r3, .L31+4
 502 0312 1A70     		strb	r2, [r3, #0]
 147:../src/sensors.c ****     batteryWarningVoltage = i * mcfg.vbatmincellvoltage; // 3.3V per cell minimum, configurable in 
 503              		.loc 1 147 0
 504 0314 064B     		ldr	r3, .L31
 505 0316 93F8FC30 		ldrb	r3, [r3, #252]	@ zero_extendqisi2
 506 031a 7A68     		ldr	r2, [r7, #4]
 507 031c 92B2     		uxth	r2, r2
 508 031e 02FB03F3 		mul	r3, r2, r3
 509 0322 9AB2     		uxth	r2, r3
 510 0324 044B     		ldr	r3, .L31+8
 511 0326 1A80     		strh	r2, [r3, #0]	@ movhi
 148:../src/sensors.c **** }
 512              		.loc 1 148 0
 513 0328 07F10807 		add	r7, r7, #8
 514 032c BD46     		mov	sp, r7
 515 032e 80BD     		pop	{r7, pc}
 516              	.L32:
 517              		.align	2
 518              	.L31:
 519 0330 00000000 		.word	mcfg
 520 0334 00000000 		.word	batteryCellCount
 521 0338 00000000 		.word	batteryWarningVoltage
 522              		.cfi_endproc
 523              	.LFE31:
 525              		.align	2
 526              		.thumb
 527              		.thumb_func
 529              	alignSensors:
 530              	.LFB32:
 149:../src/sensors.c **** 
 150:../src/sensors.c **** // ALIGN_GYRO = 0,
 151:../src/sensors.c **** // ALIGN_ACCEL = 1,
 152:../src/sensors.c **** // ALIGN_MAG = 2
 153:../src/sensors.c **** static void alignSensors(uint8_t type, int16_t *data)
 154:../src/sensors.c **** {
 531              		.loc 1 154 0
 532              		.cfi_startproc
 533              		@ args = 0, pretend = 0, frame = 24
 534              		@ frame_needed = 1, uses_anonymous_args = 0
 535              		@ link register save eliminated.
 536 033c 80B4     		push	{r7}
 537              	.LCFI9:
 538              		.cfi_def_cfa_offset 4
 539              		.cfi_offset 7, -4
 540 033e 87B0     		sub	sp, sp, #28
 541              	.LCFI10:
 542              		.cfi_def_cfa_offset 32
 543 0340 00AF     		add	r7, sp, #0
 544              	.LCFI11:
 545              		.cfi_def_cfa_register 7
 546 0342 0346     		mov	r3, r0
 547 0344 3960     		str	r1, [r7, #0]
 548 0346 FB71     		strb	r3, [r7, #7]
 155:../src/sensors.c ****     int i;
 156:../src/sensors.c ****     int16_t tmp[3];
 157:../src/sensors.c **** 
 158:../src/sensors.c ****     // make a copy :(
 159:../src/sensors.c ****     tmp[0] = data[0];
 549              		.loc 1 159 0
 550 0348 3B68     		ldr	r3, [r7, #0]
 551 034a 1B88     		ldrh	r3, [r3, #0]
 552 034c BB81     		strh	r3, [r7, #12]	@ movhi
 160:../src/sensors.c ****     tmp[1] = data[1];
 553              		.loc 1 160 0
 554 034e 3B68     		ldr	r3, [r7, #0]
 555 0350 5B88     		ldrh	r3, [r3, #2]
 556 0352 FB81     		strh	r3, [r7, #14]	@ movhi
 161:../src/sensors.c ****     tmp[2] = data[2];
 557              		.loc 1 161 0
 558 0354 3B68     		ldr	r3, [r7, #0]
 559 0356 9B88     		ldrh	r3, [r3, #4]
 560 0358 3B82     		strh	r3, [r7, #16]	@ movhi
 162:../src/sensors.c **** 
 163:../src/sensors.c ****     for (i = 0; i < 3; i++) {
 561              		.loc 1 163 0
 562 035a 4FF00003 		mov	r3, #0
 563 035e 7B61     		str	r3, [r7, #20]
 564 0360 3CE0     		b	.L34
 565              	.L37:
 566              	.LBB2:
 164:../src/sensors.c ****         int8_t axis = mcfg.align[type][i];
 567              		.loc 1 164 0
 568 0362 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 569 0364 2149     		ldr	r1, .L38
 570 0366 1346     		mov	r3, r2
 571 0368 4FEA4303 		lsl	r3, r3, #1
 572 036c 9B18     		adds	r3, r3, r2
 573 036e CA18     		adds	r2, r1, r3
 574 0370 7B69     		ldr	r3, [r7, #20]
 575 0372 D318     		adds	r3, r2, r3
 576 0374 03F1D803 		add	r3, r3, #216
 577 0378 9B78     		ldrb	r3, [r3, #2]
 578 037a FB74     		strb	r3, [r7, #19]
 165:../src/sensors.c ****         if (axis > 0)
 579              		.loc 1 165 0
 580 037c 97F91330 		ldrsb	r3, [r7, #19]
 581 0380 002B     		cmp	r3, #0
 582 0382 11DD     		ble	.L35
 166:../src/sensors.c ****             data[axis - 1] = tmp[i];
 583              		.loc 1 166 0
 584 0384 97F91330 		ldrsb	r3, [r7, #19]
 585 0388 03F1FF33 		add	r3, r3, #-1
 586 038c 4FEA4303 		lsl	r3, r3, #1
 587 0390 3A68     		ldr	r2, [r7, #0]
 588 0392 D218     		adds	r2, r2, r3
 589 0394 7B69     		ldr	r3, [r7, #20]
 590 0396 4FEA4303 		lsl	r3, r3, #1
 591 039a 07F11801 		add	r1, r7, #24
 592 039e CB18     		adds	r3, r1, r3
 593 03a0 33F80C3C 		ldrh	r3, [r3, #-12]
 594 03a4 1380     		strh	r3, [r2, #0]	@ movhi
 595 03a6 15E0     		b	.L36
 596              	.L35:
 167:../src/sensors.c ****         else
 168:../src/sensors.c ****             data[-axis - 1] = -tmp[i];
 597              		.loc 1 168 0
 598 03a8 97F91330 		ldrsb	r3, [r7, #19]
 599 03ac 6FEA0303 		mvn	r3, r3
 600 03b0 4FEA4303 		lsl	r3, r3, #1
 601 03b4 3A68     		ldr	r2, [r7, #0]
 602 03b6 D218     		adds	r2, r2, r3
 603 03b8 7B69     		ldr	r3, [r7, #20]
 604 03ba 4FEA4303 		lsl	r3, r3, #1
 605 03be 07F11801 		add	r1, r7, #24
 606 03c2 CB18     		adds	r3, r1, r3
 607 03c4 33F80C3C 		ldrh	r3, [r3, #-12]
 608 03c8 9BB2     		uxth	r3, r3
 609 03ca C3F10003 		rsb	r3, r3, #0
 610 03ce 9BB2     		uxth	r3, r3
 611 03d0 9BB2     		uxth	r3, r3
 612 03d2 1380     		strh	r3, [r2, #0]	@ movhi
 613              	.L36:
 614              	.LBE2:
 163:../src/sensors.c ****     for (i = 0; i < 3; i++) {
 615              		.loc 1 163 0
 616 03d4 7B69     		ldr	r3, [r7, #20]
 617 03d6 03F10103 		add	r3, r3, #1
 618 03da 7B61     		str	r3, [r7, #20]
 619              	.L34:
 163:../src/sensors.c ****     for (i = 0; i < 3; i++) {
 620              		.loc 1 163 0 is_stmt 0 discriminator 1
 621 03dc 7B69     		ldr	r3, [r7, #20]
 622 03de 022B     		cmp	r3, #2
 623 03e0 BFDD     		ble	.L37
 169:../src/sensors.c ****     }
 170:../src/sensors.c **** }
 624              		.loc 1 170 0 is_stmt 1
 625 03e2 07F11C07 		add	r7, r7, #28
 626 03e6 BD46     		mov	sp, r7
 627 03e8 80BC     		pop	{r7}
 628 03ea 7047     		bx	lr
 629              	.L39:
 630              		.align	2
 631              	.L38:
 632 03ec 00000000 		.word	mcfg
 633              		.cfi_endproc
 634              	.LFE32:
 636              		.align	2
 637              		.thumb
 638              		.thumb_func
 640              	ACC_Common:
 641              	.LFB33:
 171:../src/sensors.c **** 
 172:../src/sensors.c **** static void ACC_Common(void)
 173:../src/sensors.c **** {
 642              		.loc 1 173 0
 643              		.cfi_startproc
 644              		@ args = 0, pretend = 0, frame = 8
 645              		@ frame_needed = 1, uses_anonymous_args = 0
 646 03f0 80B5     		push	{r7, lr}
 647              	.LCFI12:
 648              		.cfi_def_cfa_offset 8
 649              		.cfi_offset 7, -8
 650              		.cfi_offset 14, -4
 651 03f2 82B0     		sub	sp, sp, #8
 652              	.LCFI13:
 653              		.cfi_def_cfa_offset 16
 654 03f4 00AF     		add	r7, sp, #0
 655              	.LCFI14:
 656              		.cfi_def_cfa_register 7
 174:../src/sensors.c ****     static int32_t a[3];
 175:../src/sensors.c ****     int axis;
 176:../src/sensors.c **** 
 177:../src/sensors.c ****     if (calibratingA > 0) {
 657              		.loc 1 177 0
 658 03f6 554B     		ldr	r3, .L53
 659 03f8 1B88     		ldrh	r3, [r3, #0]
 660 03fa 002B     		cmp	r3, #0
 661 03fc 7BD0     		beq	.L41
 178:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 662              		.loc 1 178 0
 663 03fe 4FF00003 		mov	r3, #0
 664 0402 7B60     		str	r3, [r7, #4]
 665 0404 2CE0     		b	.L42
 666              	.L44:
 179:../src/sensors.c ****             // Reset a[axis] at start of calibration
 180:../src/sensors.c ****             if (calibratingA == 400)
 667              		.loc 1 180 0
 668 0406 514B     		ldr	r3, .L53
 669 0408 1B88     		ldrh	r3, [r3, #0]
 670 040a B3F5C87F 		cmp	r3, #400
 671 040e 05D1     		bne	.L43
 181:../src/sensors.c ****                 a[axis] = 0;
 672              		.loc 1 181 0
 673 0410 4F4B     		ldr	r3, .L53+4
 674 0412 7A68     		ldr	r2, [r7, #4]
 675 0414 4FF00001 		mov	r1, #0
 676 0418 43F82210 		str	r1, [r3, r2, lsl #2]
 677              	.L43:
 182:../src/sensors.c ****             // Sum up 400 readings
 183:../src/sensors.c ****             a[axis] += accADC[axis];
 678              		.loc 1 183 0
 679 041c 4C4B     		ldr	r3, .L53+4
 680 041e 7A68     		ldr	r2, [r7, #4]
 681 0420 53F82220 		ldr	r2, [r3, r2, lsl #2]
 682 0424 4B4B     		ldr	r3, .L53+8
 683 0426 7968     		ldr	r1, [r7, #4]
 684 0428 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 685 042c 1BB2     		sxth	r3, r3
 686 042e D118     		adds	r1, r2, r3
 687 0430 474B     		ldr	r3, .L53+4
 688 0432 7A68     		ldr	r2, [r7, #4]
 689 0434 43F82210 		str	r1, [r3, r2, lsl #2]
 184:../src/sensors.c ****             // Clear global variables for next reading
 185:../src/sensors.c ****             accADC[axis] = 0;
 690              		.loc 1 185 0
 691 0438 464B     		ldr	r3, .L53+8
 692 043a 7A68     		ldr	r2, [r7, #4]
 693 043c 4FF00001 		mov	r1, #0
 694 0440 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 186:../src/sensors.c ****             mcfg.accZero[axis] = 0;
 695              		.loc 1 186 0
 696 0444 444A     		ldr	r2, .L53+12
 697 0446 7B68     		ldr	r3, [r7, #4]
 698 0448 03F17403 		add	r3, r3, #116
 699 044c 4FEA4303 		lsl	r3, r3, #1
 700 0450 D318     		adds	r3, r2, r3
 701 0452 4FF00002 		mov	r2, #0
 702 0456 DA80     		strh	r2, [r3, #6]	@ movhi
 178:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 703              		.loc 1 178 0
 704 0458 7B68     		ldr	r3, [r7, #4]
 705 045a 03F10103 		add	r3, r3, #1
 706 045e 7B60     		str	r3, [r7, #4]
 707              	.L42:
 178:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 708              		.loc 1 178 0 is_stmt 0 discriminator 1
 709 0460 7B68     		ldr	r3, [r7, #4]
 710 0462 022B     		cmp	r3, #2
 711 0464 CFDD     		ble	.L44
 187:../src/sensors.c ****         }
 188:../src/sensors.c ****         // Calculate average, shift Z down by acc_1G and store values in EEPROM at end of calibrati
 189:../src/sensors.c ****         if (calibratingA == 1) {
 712              		.loc 1 189 0 is_stmt 1
 713 0466 394B     		ldr	r3, .L53
 714 0468 1B88     		ldrh	r3, [r3, #0]
 715 046a 012B     		cmp	r3, #1
 716 046c 3CD1     		bne	.L45
 190:../src/sensors.c ****             mcfg.accZero[ROLL] = a[ROLL] / 400;
 717              		.loc 1 190 0
 718 046e 384B     		ldr	r3, .L53+4
 719 0470 1B68     		ldr	r3, [r3, #0]
 720 0472 3A4A     		ldr	r2, .L53+16
 721 0474 82FB0312 		smull	r1, r2, r2, r3
 722 0478 4FEAE212 		asr	r2, r2, #7
 723 047c 4FEAE373 		asr	r3, r3, #31
 724 0480 D31A     		subs	r3, r2, r3
 725 0482 9AB2     		uxth	r2, r3
 726 0484 344B     		ldr	r3, .L53+12
 727 0486 A3F8EE20 		strh	r2, [r3, #238]	@ movhi
 191:../src/sensors.c ****             mcfg.accZero[PITCH] = a[PITCH] / 400;
 728              		.loc 1 191 0
 729 048a 314B     		ldr	r3, .L53+4
 730 048c 5B68     		ldr	r3, [r3, #4]
 731 048e 334A     		ldr	r2, .L53+16
 732 0490 82FB0312 		smull	r1, r2, r2, r3
 733 0494 4FEAE212 		asr	r2, r2, #7
 734 0498 4FEAE373 		asr	r3, r3, #31
 735 049c D31A     		subs	r3, r2, r3
 736 049e 9AB2     		uxth	r2, r3
 737 04a0 2D4B     		ldr	r3, .L53+12
 738 04a2 A3F8F020 		strh	r2, [r3, #240]	@ movhi
 192:../src/sensors.c ****             mcfg.accZero[YAW] = a[YAW] / 400 - acc_1G;       // for nunchuk 200=1G
 739              		.loc 1 192 0
 740 04a6 2A4B     		ldr	r3, .L53+4
 741 04a8 9B68     		ldr	r3, [r3, #8]
 742 04aa 2C4A     		ldr	r2, .L53+16
 743 04ac 82FB0312 		smull	r1, r2, r2, r3
 744 04b0 4FEAE212 		asr	r2, r2, #7
 745 04b4 4FEAE373 		asr	r3, r3, #31
 746 04b8 D31A     		subs	r3, r2, r3
 747 04ba 9AB2     		uxth	r2, r3
 748 04bc 284B     		ldr	r3, .L53+20
 749 04be 1B88     		ldrh	r3, [r3, #0]
 750 04c0 D31A     		subs	r3, r2, r3
 751 04c2 9BB2     		uxth	r3, r3
 752 04c4 9AB2     		uxth	r2, r3
 753 04c6 244B     		ldr	r3, .L53+12
 754 04c8 A3F8F220 		strh	r2, [r3, #242]	@ movhi
 193:../src/sensors.c ****             cfg.angleTrim[ROLL] = 0;
 755              		.loc 1 193 0
 756 04cc 254B     		ldr	r3, .L53+24
 757 04ce 4FF00002 		mov	r2, #0
 758 04d2 1A85     		strh	r2, [r3, #40]	@ movhi
 194:../src/sensors.c ****             cfg.angleTrim[PITCH] = 0;
 759              		.loc 1 194 0
 760 04d4 234B     		ldr	r3, .L53+24
 761 04d6 4FF00002 		mov	r2, #0
 762 04da 5A85     		strh	r2, [r3, #42]	@ movhi
 195:../src/sensors.c ****             writeEEPROM(1, true);      // write accZero in EEPROM
 763              		.loc 1 195 0
 764 04dc 4FF00100 		mov	r0, #1
 765 04e0 4FF00101 		mov	r1, #1
 766 04e4 FFF7FEFF 		bl	writeEEPROM
 767              	.L45:
 196:../src/sensors.c ****         }
 197:../src/sensors.c ****         calibratingA--;
 768              		.loc 1 197 0
 769 04e8 184B     		ldr	r3, .L53
 770 04ea 1B88     		ldrh	r3, [r3, #0]
 771 04ec 03F1FF33 		add	r3, r3, #-1
 772 04f0 9AB2     		uxth	r2, r3
 773 04f2 164B     		ldr	r3, .L53
 774 04f4 1A80     		strh	r2, [r3, #0]	@ movhi
 775              	.L41:
 198:../src/sensors.c ****     }
 199:../src/sensors.c **** 
 200:../src/sensors.c ****     if (feature(FEATURE_INFLIGHT_ACC_CAL)) {
 776              		.loc 1 200 0
 777 04f6 4FF00400 		mov	r0, #4
 778 04fa FFF7FEFF 		bl	feature
 779 04fe 0346     		mov	r3, r0
 780 0500 002B     		cmp	r3, #0
 781 0502 00F0D980 		beq	.L46
 782              	.LBB3:
 201:../src/sensors.c ****         static int32_t b[3];
 202:../src/sensors.c ****         static int16_t accZero_saved[3] = { 0, 0, 0 };
 203:../src/sensors.c ****         static int16_t angleTrim_saved[2] = { 0, 0 };
 204:../src/sensors.c ****         // Saving old zeropoints before measurement
 205:../src/sensors.c ****         if (InflightcalibratingA == 50) {
 783              		.loc 1 205 0
 784 0506 184B     		ldr	r3, .L53+28
 785 0508 1B88     		ldrh	r3, [r3, #0]
 786 050a 322B     		cmp	r3, #50
 787 050c 16D1     		bne	.L47
 206:../src/sensors.c ****             accZero_saved[ROLL] = mcfg.accZero[ROLL];
 788              		.loc 1 206 0
 789 050e 124B     		ldr	r3, .L53+12
 790 0510 B3F8EE20 		ldrh	r2, [r3, #238]
 791 0514 154B     		ldr	r3, .L53+32
 792 0516 1A80     		strh	r2, [r3, #0]	@ movhi
 207:../src/sensors.c ****             accZero_saved[PITCH] = mcfg.accZero[PITCH];
 793              		.loc 1 207 0
 794 0518 0F4B     		ldr	r3, .L53+12
 795 051a B3F8F020 		ldrh	r2, [r3, #240]
 796 051e 134B     		ldr	r3, .L53+32
 797 0520 5A80     		strh	r2, [r3, #2]	@ movhi
 208:../src/sensors.c ****             accZero_saved[YAW] = mcfg.accZero[YAW];
 798              		.loc 1 208 0
 799 0522 0D4B     		ldr	r3, .L53+12
 800 0524 B3F8F220 		ldrh	r2, [r3, #242]
 801 0528 104B     		ldr	r3, .L53+32
 802 052a 9A80     		strh	r2, [r3, #4]	@ movhi
 209:../src/sensors.c ****             angleTrim_saved[ROLL] = cfg.angleTrim[ROLL];
 803              		.loc 1 209 0
 804 052c 0D4B     		ldr	r3, .L53+24
 805 052e 1A8D     		ldrh	r2, [r3, #40]
 806 0530 0F4B     		ldr	r3, .L53+36
 807 0532 1A80     		strh	r2, [r3, #0]	@ movhi
 210:../src/sensors.c ****             angleTrim_saved[PITCH] = cfg.angleTrim[PITCH];
 808              		.loc 1 210 0
 809 0534 0B4B     		ldr	r3, .L53+24
 810 0536 5A8D     		ldrh	r2, [r3, #42]
 811 0538 0D4B     		ldr	r3, .L53+36
 812 053a 5A80     		strh	r2, [r3, #2]	@ movhi
 813              	.L47:
 211:../src/sensors.c ****         }
 212:../src/sensors.c ****         if (InflightcalibratingA > 0) {
 814              		.loc 1 212 0
 815 053c 0A4B     		ldr	r3, .L53+28
 816 053e 1B88     		ldrh	r3, [r3, #0]
 817 0540 002B     		cmp	r3, #0
 818 0542 74D0     		beq	.L48
 213:../src/sensors.c ****             for (axis = 0; axis < 3; axis++) {
 819              		.loc 1 213 0
 820 0544 4FF00003 		mov	r3, #0
 821 0548 7B60     		str	r3, [r7, #4]
 822 054a 3FE0     		b	.L49
 823              	.L54:
 824              		.align	2
 825              	.L53:
 826 054c 00000000 		.word	calibratingA
 827 0550 3C010000 		.word	a.9085
 828 0554 00000000 		.word	accADC
 829 0558 00000000 		.word	mcfg
 830 055c 1F85EB51 		.word	1374389535
 831 0560 00000000 		.word	acc_1G
 832 0564 00000000 		.word	cfg
 833 0568 00000000 		.word	InflightcalibratingA
 834 056c 48010000 		.word	accZero_saved.9091
 835 0570 50010000 		.word	angleTrim_saved.9092
 836              	.L51:
 214:../src/sensors.c ****                 // Reset a[axis] at start of calibration
 215:../src/sensors.c ****                 if (InflightcalibratingA == 50)
 837              		.loc 1 215 0
 838 0574 644B     		ldr	r3, .L55
 839 0576 1B88     		ldrh	r3, [r3, #0]
 840 0578 322B     		cmp	r3, #50
 841 057a 05D1     		bne	.L50
 216:../src/sensors.c ****                     b[axis] = 0;
 842              		.loc 1 216 0
 843 057c 634B     		ldr	r3, .L55+4
 844 057e 7A68     		ldr	r2, [r7, #4]
 845 0580 4FF00001 		mov	r1, #0
 846 0584 43F82210 		str	r1, [r3, r2, lsl #2]
 847              	.L50:
 217:../src/sensors.c ****                 // Sum up 50 readings
 218:../src/sensors.c ****                 b[axis] += accADC[axis];
 848              		.loc 1 218 0
 849 0588 604B     		ldr	r3, .L55+4
 850 058a 7A68     		ldr	r2, [r7, #4]
 851 058c 53F82220 		ldr	r2, [r3, r2, lsl #2]
 852 0590 5F4B     		ldr	r3, .L55+8
 853 0592 7968     		ldr	r1, [r7, #4]
 854 0594 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 855 0598 1BB2     		sxth	r3, r3
 856 059a D118     		adds	r1, r2, r3
 857 059c 5B4B     		ldr	r3, .L55+4
 858 059e 7A68     		ldr	r2, [r7, #4]
 859 05a0 43F82210 		str	r1, [r3, r2, lsl #2]
 219:../src/sensors.c ****                 // Clear global variables for next reading
 220:../src/sensors.c ****                 accADC[axis] = 0;
 860              		.loc 1 220 0
 861 05a4 5A4B     		ldr	r3, .L55+8
 862 05a6 7A68     		ldr	r2, [r7, #4]
 863 05a8 4FF00001 		mov	r1, #0
 864 05ac 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 221:../src/sensors.c ****                 mcfg.accZero[axis] = 0;
 865              		.loc 1 221 0
 866 05b0 584A     		ldr	r2, .L55+12
 867 05b2 7B68     		ldr	r3, [r7, #4]
 868 05b4 03F17403 		add	r3, r3, #116
 869 05b8 4FEA4303 		lsl	r3, r3, #1
 870 05bc D318     		adds	r3, r2, r3
 871 05be 4FF00002 		mov	r2, #0
 872 05c2 DA80     		strh	r2, [r3, #6]	@ movhi
 213:../src/sensors.c ****             for (axis = 0; axis < 3; axis++) {
 873              		.loc 1 213 0
 874 05c4 7B68     		ldr	r3, [r7, #4]
 875 05c6 03F10103 		add	r3, r3, #1
 876 05ca 7B60     		str	r3, [r7, #4]
 877              	.L49:
 213:../src/sensors.c ****             for (axis = 0; axis < 3; axis++) {
 878              		.loc 1 213 0 is_stmt 0 discriminator 1
 879 05cc 7B68     		ldr	r3, [r7, #4]
 880 05ce 022B     		cmp	r3, #2
 881 05d0 D0DD     		ble	.L51
 222:../src/sensors.c ****             }
 223:../src/sensors.c ****             // all values are measured
 224:../src/sensors.c ****             if (InflightcalibratingA == 1) {
 882              		.loc 1 224 0 is_stmt 1
 883 05d2 4D4B     		ldr	r3, .L55
 884 05d4 1B88     		ldrh	r3, [r3, #0]
 885 05d6 012B     		cmp	r3, #1
 886 05d8 22D1     		bne	.L52
 225:../src/sensors.c ****                 AccInflightCalibrationActive = 0;
 887              		.loc 1 225 0
 888 05da 4F4B     		ldr	r3, .L55+16
 889 05dc 4FF00002 		mov	r2, #0
 890 05e0 1A80     		strh	r2, [r3, #0]	@ movhi
 226:../src/sensors.c ****                 AccInflightCalibrationMeasurementDone = 1;
 891              		.loc 1 226 0
 892 05e2 4E4B     		ldr	r3, .L55+20
 893 05e4 4FF00102 		mov	r2, #1
 894 05e8 1A80     		strh	r2, [r3, #0]	@ movhi
 227:../src/sensors.c ****                 toggleBeep = 2;      // buzzer for indicatiing the end of calibration
 895              		.loc 1 227 0
 896 05ea 4D4B     		ldr	r3, .L55+24
 897 05ec 4FF00202 		mov	r2, #2
 898 05f0 1A70     		strb	r2, [r3, #0]
 228:../src/sensors.c ****                 // recover saved values to maintain current flight behavior until new values are tr
 229:../src/sensors.c ****                 mcfg.accZero[ROLL] = accZero_saved[ROLL];
 899              		.loc 1 229 0
 900 05f2 4C4B     		ldr	r3, .L55+28
 901 05f4 1A88     		ldrh	r2, [r3, #0]
 902 05f6 474B     		ldr	r3, .L55+12
 903 05f8 A3F8EE20 		strh	r2, [r3, #238]	@ movhi
 230:../src/sensors.c ****                 mcfg.accZero[PITCH] = accZero_saved[PITCH];
 904              		.loc 1 230 0
 905 05fc 494B     		ldr	r3, .L55+28
 906 05fe 5A88     		ldrh	r2, [r3, #2]
 907 0600 444B     		ldr	r3, .L55+12
 908 0602 A3F8F020 		strh	r2, [r3, #240]	@ movhi
 231:../src/sensors.c ****                 mcfg.accZero[YAW] = accZero_saved[YAW];
 909              		.loc 1 231 0
 910 0606 474B     		ldr	r3, .L55+28
 911 0608 9A88     		ldrh	r2, [r3, #4]
 912 060a 424B     		ldr	r3, .L55+12
 913 060c A3F8F220 		strh	r2, [r3, #242]	@ movhi
 232:../src/sensors.c ****                 cfg.angleTrim[ROLL] = angleTrim_saved[ROLL];
 914              		.loc 1 232 0
 915 0610 454B     		ldr	r3, .L55+32
 916 0612 1A88     		ldrh	r2, [r3, #0]
 917 0614 454B     		ldr	r3, .L55+36
 918 0616 1A85     		strh	r2, [r3, #40]	@ movhi
 233:../src/sensors.c ****                 cfg.angleTrim[PITCH] = angleTrim_saved[PITCH];
 919              		.loc 1 233 0
 920 0618 434B     		ldr	r3, .L55+32
 921 061a 5A88     		ldrh	r2, [r3, #2]
 922 061c 434B     		ldr	r3, .L55+36
 923 061e 5A85     		strh	r2, [r3, #42]	@ movhi
 924              	.L52:
 234:../src/sensors.c ****             }
 235:../src/sensors.c ****             InflightcalibratingA--;
 925              		.loc 1 235 0
 926 0620 394B     		ldr	r3, .L55
 927 0622 1B88     		ldrh	r3, [r3, #0]
 928 0624 03F1FF33 		add	r3, r3, #-1
 929 0628 9AB2     		uxth	r2, r3
 930 062a 374B     		ldr	r3, .L55
 931 062c 1A80     		strh	r2, [r3, #0]	@ movhi
 932              	.L48:
 236:../src/sensors.c ****         }
 237:../src/sensors.c ****         // Calculate average, shift Z down by acc_1G and store values in EEPROM at end of calibrati
 238:../src/sensors.c ****         if (AccInflightCalibrationSavetoEEProm == 1) {      // the copter is landed, disarmed and t
 933              		.loc 1 238 0
 934 062e 404B     		ldr	r3, .L55+40
 935 0630 1B88     		ldrh	r3, [r3, #0]
 936 0632 012B     		cmp	r3, #1
 937 0634 40D1     		bne	.L46
 239:../src/sensors.c ****             AccInflightCalibrationSavetoEEProm = 0;
 938              		.loc 1 239 0
 939 0636 3E4B     		ldr	r3, .L55+40
 940 0638 4FF00002 		mov	r2, #0
 941 063c 1A80     		strh	r2, [r3, #0]	@ movhi
 240:../src/sensors.c ****             mcfg.accZero[ROLL] = b[ROLL] / 50;
 942              		.loc 1 240 0
 943 063e 334B     		ldr	r3, .L55+4
 944 0640 1B68     		ldr	r3, [r3, #0]
 945 0642 3C4A     		ldr	r2, .L55+44
 946 0644 82FB0312 		smull	r1, r2, r2, r3
 947 0648 4FEA2212 		asr	r2, r2, #4
 948 064c 4FEAE373 		asr	r3, r3, #31
 949 0650 D31A     		subs	r3, r2, r3
 950 0652 9AB2     		uxth	r2, r3
 951 0654 2F4B     		ldr	r3, .L55+12
 952 0656 A3F8EE20 		strh	r2, [r3, #238]	@ movhi
 241:../src/sensors.c ****             mcfg.accZero[PITCH] = b[PITCH] / 50;
 953              		.loc 1 241 0
 954 065a 2C4B     		ldr	r3, .L55+4
 955 065c 5B68     		ldr	r3, [r3, #4]
 956 065e 354A     		ldr	r2, .L55+44
 957 0660 82FB0312 		smull	r1, r2, r2, r3
 958 0664 4FEA2212 		asr	r2, r2, #4
 959 0668 4FEAE373 		asr	r3, r3, #31
 960 066c D31A     		subs	r3, r2, r3
 961 066e 9AB2     		uxth	r2, r3
 962 0670 284B     		ldr	r3, .L55+12
 963 0672 A3F8F020 		strh	r2, [r3, #240]	@ movhi
 242:../src/sensors.c ****             mcfg.accZero[YAW] = b[YAW] / 50 - acc_1G;    // for nunchuk 200=1G
 964              		.loc 1 242 0
 965 0676 254B     		ldr	r3, .L55+4
 966 0678 9B68     		ldr	r3, [r3, #8]
 967 067a 2E4A     		ldr	r2, .L55+44
 968 067c 82FB0312 		smull	r1, r2, r2, r3
 969 0680 4FEA2212 		asr	r2, r2, #4
 970 0684 4FEAE373 		asr	r3, r3, #31
 971 0688 D31A     		subs	r3, r2, r3
 972 068a 9AB2     		uxth	r2, r3
 973 068c 2A4B     		ldr	r3, .L55+48
 974 068e 1B88     		ldrh	r3, [r3, #0]
 975 0690 D31A     		subs	r3, r2, r3
 976 0692 9BB2     		uxth	r3, r3
 977 0694 9AB2     		uxth	r2, r3
 978 0696 1F4B     		ldr	r3, .L55+12
 979 0698 A3F8F220 		strh	r2, [r3, #242]	@ movhi
 243:../src/sensors.c ****             cfg.angleTrim[ROLL] = 0;
 980              		.loc 1 243 0
 981 069c 234B     		ldr	r3, .L55+36
 982 069e 4FF00002 		mov	r2, #0
 983 06a2 1A85     		strh	r2, [r3, #40]	@ movhi
 244:../src/sensors.c ****             cfg.angleTrim[PITCH] = 0;
 984              		.loc 1 244 0
 985 06a4 214B     		ldr	r3, .L55+36
 986 06a6 4FF00002 		mov	r2, #0
 987 06aa 5A85     		strh	r2, [r3, #42]	@ movhi
 245:../src/sensors.c ****             writeEEPROM(1, true);          // write accZero in EEPROM
 988              		.loc 1 245 0
 989 06ac 4FF00100 		mov	r0, #1
 990 06b0 4FF00101 		mov	r1, #1
 991 06b4 FFF7FEFF 		bl	writeEEPROM
 992              	.L46:
 993              	.LBE3:
 246:../src/sensors.c ****         }
 247:../src/sensors.c ****     }
 248:../src/sensors.c **** 
 249:../src/sensors.c ****     accADC[ROLL] -= mcfg.accZero[ROLL];
 994              		.loc 1 249 0
 995 06b8 154B     		ldr	r3, .L55+8
 996 06ba 1B88     		ldrh	r3, [r3, #0]
 997 06bc 9AB2     		uxth	r2, r3
 998 06be 154B     		ldr	r3, .L55+12
 999 06c0 B3F8EE30 		ldrh	r3, [r3, #238]
 1000 06c4 9BB2     		uxth	r3, r3
 1001 06c6 D31A     		subs	r3, r2, r3
 1002 06c8 9BB2     		uxth	r3, r3
 1003 06ca 9AB2     		uxth	r2, r3
 1004 06cc 104B     		ldr	r3, .L55+8
 1005 06ce 1A80     		strh	r2, [r3, #0]	@ movhi
 250:../src/sensors.c ****     accADC[PITCH] -= mcfg.accZero[PITCH];
 1006              		.loc 1 250 0
 1007 06d0 0F4B     		ldr	r3, .L55+8
 1008 06d2 5B88     		ldrh	r3, [r3, #2]
 1009 06d4 9AB2     		uxth	r2, r3
 1010 06d6 0F4B     		ldr	r3, .L55+12
 1011 06d8 B3F8F030 		ldrh	r3, [r3, #240]
 1012 06dc 9BB2     		uxth	r3, r3
 1013 06de D31A     		subs	r3, r2, r3
 1014 06e0 9BB2     		uxth	r3, r3
 1015 06e2 9AB2     		uxth	r2, r3
 1016 06e4 0A4B     		ldr	r3, .L55+8
 1017 06e6 5A80     		strh	r2, [r3, #2]	@ movhi
 251:../src/sensors.c ****     accADC[YAW] -= mcfg.accZero[YAW];
 1018              		.loc 1 251 0
 1019 06e8 094B     		ldr	r3, .L55+8
 1020 06ea 9B88     		ldrh	r3, [r3, #4]
 1021 06ec 9AB2     		uxth	r2, r3
 1022 06ee 094B     		ldr	r3, .L55+12
 1023 06f0 B3F8F230 		ldrh	r3, [r3, #242]
 1024 06f4 9BB2     		uxth	r3, r3
 1025 06f6 D31A     		subs	r3, r2, r3
 1026 06f8 9BB2     		uxth	r3, r3
 1027 06fa 9AB2     		uxth	r2, r3
 1028 06fc 044B     		ldr	r3, .L55+8
 1029 06fe 9A80     		strh	r2, [r3, #4]	@ movhi
 252:../src/sensors.c **** }
 1030              		.loc 1 252 0
 1031 0700 07F10807 		add	r7, r7, #8
 1032 0704 BD46     		mov	sp, r7
 1033 0706 80BD     		pop	{r7, pc}
 1034              	.L56:
 1035              		.align	2
 1036              	.L55:
 1037 0708 00000000 		.word	InflightcalibratingA
 1038 070c 54010000 		.word	b.9090
 1039 0710 00000000 		.word	accADC
 1040 0714 00000000 		.word	mcfg
 1041 0718 00000000 		.word	AccInflightCalibrationActive
 1042 071c 00000000 		.word	AccInflightCalibrationMeasurementDone
 1043 0720 00000000 		.word	toggleBeep
 1044 0724 48010000 		.word	accZero_saved.9091
 1045 0728 50010000 		.word	angleTrim_saved.9092
 1046 072c 00000000 		.word	cfg
 1047 0730 00000000 		.word	AccInflightCalibrationSavetoEEProm
 1048 0734 1F85EB51 		.word	1374389535
 1049 0738 00000000 		.word	acc_1G
 1050              		.cfi_endproc
 1051              	.LFE33:
 1053              		.align	2
 1054              		.global	ACC_getADC
 1055              		.thumb
 1056              		.thumb_func
 1058              	ACC_getADC:
 1059              	.LFB34:
 253:../src/sensors.c **** 
 254:../src/sensors.c **** void ACC_getADC(void)
 255:../src/sensors.c **** {
 1060              		.loc 1 255 0
 1061              		.cfi_startproc
 1062              		@ args = 0, pretend = 0, frame = 0
 1063              		@ frame_needed = 1, uses_anonymous_args = 0
 1064 073c 80B5     		push	{r7, lr}
 1065              	.LCFI15:
 1066              		.cfi_def_cfa_offset 8
 1067              		.cfi_offset 7, -8
 1068              		.cfi_offset 14, -4
 1069 073e 00AF     		add	r7, sp, #0
 1070              	.LCFI16:
 1071              		.cfi_def_cfa_register 7
 256:../src/sensors.c ****     acc.read(accADC);
 1072              		.loc 1 256 0
 1073 0740 0A4B     		ldr	r3, .L60
 1074 0742 5B68     		ldr	r3, [r3, #4]
 1075 0744 0A48     		ldr	r0, .L60+4
 1076 0746 9847     		blx	r3
 257:../src/sensors.c ****     // if we have CUSTOM alignment configured, user is "assumed" to know what they're doing
 258:../src/sensors.c ****     if (mcfg.align[ALIGN_ACCEL][0])
 1077              		.loc 1 258 0
 1078 0748 0A4B     		ldr	r3, .L60+8
 1079 074a 93F8DD30 		ldrb	r3, [r3, #221]	@ zero_extendqisi2
 1080 074e 002B     		cmp	r3, #0
 1081 0750 05D0     		beq	.L58
 259:../src/sensors.c ****         alignSensors(ALIGN_ACCEL, accADC);
 1082              		.loc 1 259 0
 1083 0752 4FF00100 		mov	r0, #1
 1084 0756 0649     		ldr	r1, .L60+4
 1085 0758 FFF7F0FD 		bl	alignSensors
 1086 075c 03E0     		b	.L59
 1087              	.L58:
 260:../src/sensors.c ****     else
 261:../src/sensors.c ****         acc.align(accADC);
 1088              		.loc 1 261 0
 1089 075e 034B     		ldr	r3, .L60
 1090 0760 9B68     		ldr	r3, [r3, #8]
 1091 0762 0348     		ldr	r0, .L60+4
 1092 0764 9847     		blx	r3
 1093              	.L59:
 262:../src/sensors.c **** 
 263:../src/sensors.c ****     ACC_Common();
 1094              		.loc 1 263 0
 1095 0766 FFF743FE 		bl	ACC_Common
 264:../src/sensors.c **** }
 1096              		.loc 1 264 0
 1097 076a 80BD     		pop	{r7, pc}
 1098              	.L61:
 1099              		.align	2
 1100              	.L60:
 1101 076c 00000000 		.word	acc
 1102 0770 00000000 		.word	accADC
 1103 0774 00000000 		.word	mcfg
 1104              		.cfi_endproc
 1105              	.LFE34:
 1107              		.align	2
 1108              		.global	Baro_Common
 1109              		.thumb
 1110              		.thumb_func
 1112              	Baro_Common:
 1113              	.LFB35:
 265:../src/sensors.c **** 
 266:../src/sensors.c **** #ifdef BARO
 267:../src/sensors.c **** void Baro_Common(void)
 268:../src/sensors.c **** {
 1114              		.loc 1 268 0
 1115              		.cfi_startproc
 1116              		@ args = 0, pretend = 0, frame = 8
 1117              		@ frame_needed = 1, uses_anonymous_args = 0
 1118              		@ link register save eliminated.
 1119 0778 80B4     		push	{r7}
 1120              	.LCFI17:
 1121              		.cfi_def_cfa_offset 4
 1122              		.cfi_offset 7, -4
 1123 077a 83B0     		sub	sp, sp, #12
 1124              	.LCFI18:
 1125              		.cfi_def_cfa_offset 16
 1126 077c 00AF     		add	r7, sp, #0
 1127              	.LCFI19:
 1128              		.cfi_def_cfa_register 7
 269:../src/sensors.c ****     static int32_t baroHistTab[BARO_TAB_SIZE_MAX];
 270:../src/sensors.c ****     static int baroHistIdx;
 271:../src/sensors.c ****     int indexplus1;
 272:../src/sensors.c **** 
 273:../src/sensors.c ****     indexplus1 = (baroHistIdx + 1);
 1129              		.loc 1 273 0
 1130 077e 184B     		ldr	r3, .L64
 1131 0780 1B68     		ldr	r3, [r3, #0]
 1132 0782 03F10103 		add	r3, r3, #1
 1133 0786 7B60     		str	r3, [r7, #4]
 274:../src/sensors.c ****     if (indexplus1 == cfg.baro_tab_size)
 1134              		.loc 1 274 0
 1135 0788 164B     		ldr	r3, .L64+4
 1136 078a 93F82F30 		ldrb	r3, [r3, #47]	@ zero_extendqisi2
 1137 078e 1A46     		mov	r2, r3
 1138 0790 7B68     		ldr	r3, [r7, #4]
 1139 0792 9A42     		cmp	r2, r3
 1140 0794 02D1     		bne	.L63
 275:../src/sensors.c ****         indexplus1 = 0;
 1141              		.loc 1 275 0
 1142 0796 4FF00003 		mov	r3, #0
 1143 079a 7B60     		str	r3, [r7, #4]
 1144              	.L63:
 276:../src/sensors.c ****     baroHistTab[baroHistIdx] = baroPressure;
 1145              		.loc 1 276 0
 1146 079c 104B     		ldr	r3, .L64
 1147 079e 1A68     		ldr	r2, [r3, #0]
 1148 07a0 114B     		ldr	r3, .L64+8
 1149 07a2 1968     		ldr	r1, [r3, #0]
 1150 07a4 114B     		ldr	r3, .L64+12
 1151 07a6 43F82210 		str	r1, [r3, r2, lsl #2]
 277:../src/sensors.c ****     baroPressureSum += baroHistTab[baroHistIdx];
 1152              		.loc 1 277 0
 1153 07aa 0D4B     		ldr	r3, .L64
 1154 07ac 1A68     		ldr	r2, [r3, #0]
 1155 07ae 0F4B     		ldr	r3, .L64+12
 1156 07b0 53F82220 		ldr	r2, [r3, r2, lsl #2]
 1157 07b4 0E4B     		ldr	r3, .L64+16
 1158 07b6 1B68     		ldr	r3, [r3, #0]
 1159 07b8 D218     		adds	r2, r2, r3
 1160 07ba 0D4B     		ldr	r3, .L64+16
 1161 07bc 1A60     		str	r2, [r3, #0]
 278:../src/sensors.c ****     baroPressureSum -= baroHistTab[indexplus1];
 1162              		.loc 1 278 0
 1163 07be 0C4B     		ldr	r3, .L64+16
 1164 07c0 1A68     		ldr	r2, [r3, #0]
 1165 07c2 0A4B     		ldr	r3, .L64+12
 1166 07c4 7968     		ldr	r1, [r7, #4]
 1167 07c6 53F82130 		ldr	r3, [r3, r1, lsl #2]
 1168 07ca D21A     		subs	r2, r2, r3
 1169 07cc 084B     		ldr	r3, .L64+16
 1170 07ce 1A60     		str	r2, [r3, #0]
 279:../src/sensors.c ****     baroHistIdx = indexplus1;
 1171              		.loc 1 279 0
 1172 07d0 034B     		ldr	r3, .L64
 1173 07d2 7A68     		ldr	r2, [r7, #4]
 1174 07d4 1A60     		str	r2, [r3, #0]
 280:../src/sensors.c **** }
 1175              		.loc 1 280 0
 1176 07d6 07F10C07 		add	r7, r7, #12
 1177 07da BD46     		mov	sp, r7
 1178 07dc 80BC     		pop	{r7}
 1179 07de 7047     		bx	lr
 1180              	.L65:
 1181              		.align	2
 1182              	.L64:
 1183 07e0 78000000 		.word	baroHistIdx.9103
 1184 07e4 00000000 		.word	cfg
 1185 07e8 00000000 		.word	baroPressure
 1186 07ec 7C000000 		.word	baroHistTab.9102
 1187 07f0 00000000 		.word	baroPressureSum
 1188              		.cfi_endproc
 1189              	.LFE35:
 1191              		.align	2
 1192              		.global	Baro_update
 1193              		.thumb
 1194              		.thumb_func
 1196              	Baro_update:
 1197              	.LFB36:
 281:../src/sensors.c **** 
 282:../src/sensors.c **** 
 283:../src/sensors.c **** int Baro_update(void)
 284:../src/sensors.c **** {
 1198              		.loc 1 284 0
 1199              		.cfi_startproc
 1200              		@ args = 0, pretend = 0, frame = 0
 1201              		@ frame_needed = 1, uses_anonymous_args = 0
 1202 07f4 80B5     		push	{r7, lr}
 1203              	.LCFI20:
 1204              		.cfi_def_cfa_offset 8
 1205              		.cfi_offset 7, -8
 1206              		.cfi_offset 14, -4
 1207 07f6 00AF     		add	r7, sp, #0
 1208              	.LCFI21:
 1209              		.cfi_def_cfa_register 7
 285:../src/sensors.c ****     static uint32_t baroDeadline = 0;
 286:../src/sensors.c ****     static int state = 0;
 287:../src/sensors.c **** 
 288:../src/sensors.c ****     if ((int32_t)(currentTime - baroDeadline) < 0)
 1210              		.loc 1 288 0
 1211 07f8 214B     		ldr	r3, .L70
 1212 07fa 1A68     		ldr	r2, [r3, #0]
 1213 07fc 214B     		ldr	r3, .L70+4
 1214 07fe 1B68     		ldr	r3, [r3, #0]
 1215 0800 D31A     		subs	r3, r2, r3
 1216 0802 002B     		cmp	r3, #0
 1217 0804 02DA     		bge	.L67
 289:../src/sensors.c ****         return 0;
 1218              		.loc 1 289 0
 1219 0806 4FF00003 		mov	r3, #0
 1220 080a 37E0     		b	.L68
 1221              	.L67:
 290:../src/sensors.c **** 
 291:../src/sensors.c ****     baroDeadline = currentTime;
 1222              		.loc 1 291 0
 1223 080c 1C4B     		ldr	r3, .L70
 1224 080e 1A68     		ldr	r2, [r3, #0]
 1225 0810 1C4B     		ldr	r3, .L70+4
 1226 0812 1A60     		str	r2, [r3, #0]
 292:../src/sensors.c ****     
 293:../src/sensors.c ****     if (state) {
 1227              		.loc 1 293 0
 1228 0814 1C4B     		ldr	r3, .L70+8
 1229 0816 1B68     		ldr	r3, [r3, #0]
 1230 0818 002B     		cmp	r3, #0
 1231 081a 19D0     		beq	.L69
 294:../src/sensors.c ****         baro.get_up();
 1232              		.loc 1 294 0
 1233 081c 1B4B     		ldr	r3, .L70+12
 1234 081e 1B69     		ldr	r3, [r3, #16]
 1235 0820 9847     		blx	r3
 295:../src/sensors.c ****         baro.start_ut();
 1236              		.loc 1 295 0
 1237 0822 1A4B     		ldr	r3, .L70+12
 1238 0824 5B68     		ldr	r3, [r3, #4]
 1239 0826 9847     		blx	r3
 296:../src/sensors.c ****         baroDeadline += baro.ut_delay;
 1240              		.loc 1 296 0
 1241 0828 184B     		ldr	r3, .L70+12
 1242 082a 1B88     		ldrh	r3, [r3, #0]
 1243 082c 1A46     		mov	r2, r3
 1244 082e 154B     		ldr	r3, .L70+4
 1245 0830 1B68     		ldr	r3, [r3, #0]
 1246 0832 D218     		adds	r2, r2, r3
 1247 0834 134B     		ldr	r3, .L70+4
 1248 0836 1A60     		str	r2, [r3, #0]
 297:../src/sensors.c ****         baro.calculate(&baroPressure, &baroTemperature);
 1249              		.loc 1 297 0
 1250 0838 144B     		ldr	r3, .L70+12
 1251 083a 5B69     		ldr	r3, [r3, #20]
 1252 083c 1448     		ldr	r0, .L70+16
 1253 083e 1549     		ldr	r1, .L70+20
 1254 0840 9847     		blx	r3
 298:../src/sensors.c ****         state = 0;
 1255              		.loc 1 298 0
 1256 0842 114B     		ldr	r3, .L70+8
 1257 0844 4FF00002 		mov	r2, #0
 1258 0848 1A60     		str	r2, [r3, #0]
 299:../src/sensors.c ****         return 2;
 1259              		.loc 1 299 0
 1260 084a 4FF00203 		mov	r3, #2
 1261 084e 15E0     		b	.L68
 1262              	.L69:
 300:../src/sensors.c ****     } else {
 301:../src/sensors.c ****         baro.get_ut();
 1263              		.loc 1 301 0
 1264 0850 0E4B     		ldr	r3, .L70+12
 1265 0852 9B68     		ldr	r3, [r3, #8]
 1266 0854 9847     		blx	r3
 302:../src/sensors.c ****         baro.start_up();
 1267              		.loc 1 302 0
 1268 0856 0D4B     		ldr	r3, .L70+12
 1269 0858 DB68     		ldr	r3, [r3, #12]
 1270 085a 9847     		blx	r3
 303:../src/sensors.c ****         Baro_Common();
 1271              		.loc 1 303 0
 1272 085c FFF7FEFF 		bl	Baro_Common
 304:../src/sensors.c ****         state = 1;
 1273              		.loc 1 304 0
 1274 0860 094B     		ldr	r3, .L70+8
 1275 0862 4FF00102 		mov	r2, #1
 1276 0866 1A60     		str	r2, [r3, #0]
 305:../src/sensors.c ****         baroDeadline += baro.up_delay;
 1277              		.loc 1 305 0
 1278 0868 084B     		ldr	r3, .L70+12
 1279 086a 5B88     		ldrh	r3, [r3, #2]
 1280 086c 1A46     		mov	r2, r3
 1281 086e 054B     		ldr	r3, .L70+4
 1282 0870 1B68     		ldr	r3, [r3, #0]
 1283 0872 D218     		adds	r2, r2, r3
 1284 0874 034B     		ldr	r3, .L70+4
 1285 0876 1A60     		str	r2, [r3, #0]
 306:../src/sensors.c ****         return 1;
 1286              		.loc 1 306 0
 1287 0878 4FF00103 		mov	r3, #1
 1288              	.L68:
 307:../src/sensors.c ****     }
 308:../src/sensors.c **** }
 1289              		.loc 1 308 0
 1290 087c 1846     		mov	r0, r3
 1291 087e 80BD     		pop	{r7, pc}
 1292              	.L71:
 1293              		.align	2
 1294              	.L70:
 1295 0880 00000000 		.word	currentTime
 1296 0884 70000000 		.word	baroDeadline.9108
 1297 0888 74000000 		.word	state.9109
 1298 088c 00000000 		.word	baro
 1299 0890 00000000 		.word	baroPressure
 1300 0894 00000000 		.word	baroTemperature
 1301              		.cfi_endproc
 1302              	.LFE36:
 1304              		.align	2
 1305              		.thumb
 1306              		.thumb_func
 1308              	devClear:
 1309              	.LFB37:
 309:../src/sensors.c **** #endif /* BARO */
 310:../src/sensors.c **** 
 311:../src/sensors.c **** typedef struct stdev_t
 312:../src/sensors.c **** {
 313:../src/sensors.c ****     float m_oldM, m_newM, m_oldS, m_newS;
 314:../src/sensors.c ****     int m_n;
 315:../src/sensors.c **** } stdev_t;
 316:../src/sensors.c **** 
 317:../src/sensors.c **** static void devClear(stdev_t *dev)
 318:../src/sensors.c **** {
 1310              		.loc 1 318 0
 1311              		.cfi_startproc
 1312              		@ args = 0, pretend = 0, frame = 8
 1313              		@ frame_needed = 1, uses_anonymous_args = 0
 1314              		@ link register save eliminated.
 1315 0898 80B4     		push	{r7}
 1316              	.LCFI22:
 1317              		.cfi_def_cfa_offset 4
 1318              		.cfi_offset 7, -4
 1319 089a 83B0     		sub	sp, sp, #12
 1320              	.LCFI23:
 1321              		.cfi_def_cfa_offset 16
 1322 089c 00AF     		add	r7, sp, #0
 1323              	.LCFI24:
 1324              		.cfi_def_cfa_register 7
 1325 089e 7860     		str	r0, [r7, #4]
 319:../src/sensors.c ****     dev->m_n = 0;
 1326              		.loc 1 319 0
 1327 08a0 7B68     		ldr	r3, [r7, #4]
 1328 08a2 4FF00002 		mov	r2, #0
 1329 08a6 1A61     		str	r2, [r3, #16]
 320:../src/sensors.c **** }
 1330              		.loc 1 320 0
 1331 08a8 07F10C07 		add	r7, r7, #12
 1332 08ac BD46     		mov	sp, r7
 1333 08ae 80BC     		pop	{r7}
 1334 08b0 7047     		bx	lr
 1335              		.cfi_endproc
 1336              	.LFE37:
 1338              		.global	__aeabi_fsub
 1339 08b2 00BF     		.align	2
 1340              		.thumb
 1341              		.thumb_func
 1343              	devPush:
 1344              	.LFB38:
 321:../src/sensors.c **** 
 322:../src/sensors.c **** static void devPush(stdev_t *dev, float x)
 323:../src/sensors.c **** {
 1345              		.loc 1 323 0
 1346              		.cfi_startproc
 1347              		@ args = 0, pretend = 0, frame = 8
 1348              		@ frame_needed = 1, uses_anonymous_args = 0
 1349 08b4 B0B5     		push	{r4, r5, r7, lr}
 1350              	.LCFI25:
 1351              		.cfi_def_cfa_offset 16
 1352              		.cfi_offset 4, -16
 1353              		.cfi_offset 5, -12
 1354              		.cfi_offset 7, -8
 1355              		.cfi_offset 14, -4
 1356 08b6 82B0     		sub	sp, sp, #8
 1357              	.LCFI26:
 1358              		.cfi_def_cfa_offset 24
 1359 08b8 00AF     		add	r7, sp, #0
 1360              	.LCFI27:
 1361              		.cfi_def_cfa_register 7
 1362 08ba 7860     		str	r0, [r7, #4]
 1363 08bc 3960     		str	r1, [r7, #0]	@ float
 324:../src/sensors.c ****     dev->m_n++;
 1364              		.loc 1 324 0
 1365 08be 7B68     		ldr	r3, [r7, #4]
 1366 08c0 1B69     		ldr	r3, [r3, #16]
 1367 08c2 03F10102 		add	r2, r3, #1
 1368 08c6 7B68     		ldr	r3, [r7, #4]
 1369 08c8 1A61     		str	r2, [r3, #16]
 325:../src/sensors.c ****     if (dev->m_n == 1) {
 1370              		.loc 1 325 0
 1371 08ca 7B68     		ldr	r3, [r7, #4]
 1372 08cc 1B69     		ldr	r3, [r3, #16]
 1373 08ce 012B     		cmp	r3, #1
 1374 08d0 0AD1     		bne	.L74
 326:../src/sensors.c ****         dev->m_oldM = dev->m_newM = x;
 1375              		.loc 1 326 0
 1376 08d2 7B68     		ldr	r3, [r7, #4]
 1377 08d4 3A68     		ldr	r2, [r7, #0]	@ float
 1378 08d6 5A60     		str	r2, [r3, #4]	@ float
 1379 08d8 7B68     		ldr	r3, [r7, #4]
 1380 08da 5A68     		ldr	r2, [r3, #4]	@ float
 1381 08dc 7B68     		ldr	r3, [r7, #4]
 1382 08de 1A60     		str	r2, [r3, #0]	@ float
 327:../src/sensors.c ****         dev->m_oldS = 0.0f;
 1383              		.loc 1 327 0
 1384 08e0 7B68     		ldr	r3, [r7, #4]
 1385 08e2 254A     		ldr	r2, .L76	@ float
 1386 08e4 9A60     		str	r2, [r3, #8]	@ float
 1387 08e6 42E0     		b	.L73
 1388              	.L74:
 328:../src/sensors.c ****     } else {
 329:../src/sensors.c ****         dev->m_newM = dev->m_oldM + (x - dev->m_oldM) / dev->m_n;
 1389              		.loc 1 329 0
 1390 08e8 7B68     		ldr	r3, [r7, #4]
 1391 08ea 1C68     		ldr	r4, [r3, #0]	@ float
 1392 08ec 7B68     		ldr	r3, [r7, #4]
 1393 08ee 1B68     		ldr	r3, [r3, #0]	@ float
 1394 08f0 3868     		ldr	r0, [r7, #0]	@ float
 1395 08f2 1946     		mov	r1, r3
 1396 08f4 FFF7FEFF 		bl	__aeabi_fsub
 1397 08f8 0346     		mov	r3, r0
 1398 08fa 1D46     		mov	r5, r3
 1399 08fc 7B68     		ldr	r3, [r7, #4]
 1400 08fe 1B69     		ldr	r3, [r3, #16]
 1401 0900 1846     		mov	r0, r3
 1402 0902 FFF7FEFF 		bl	__aeabi_i2f
 1403 0906 0346     		mov	r3, r0
 1404 0908 2846     		mov	r0, r5
 1405 090a 1946     		mov	r1, r3
 1406 090c FFF7FEFF 		bl	__aeabi_fdiv
 1407 0910 0346     		mov	r3, r0
 1408 0912 2046     		mov	r0, r4
 1409 0914 1946     		mov	r1, r3
 1410 0916 FFF7FEFF 		bl	__aeabi_fadd
 1411 091a 0346     		mov	r3, r0
 1412 091c 1A46     		mov	r2, r3
 1413 091e 7B68     		ldr	r3, [r7, #4]
 1414 0920 5A60     		str	r2, [r3, #4]	@ float
 330:../src/sensors.c ****         dev->m_newS = dev->m_oldS + (x - dev->m_oldM) * (x - dev->m_newM);
 1415              		.loc 1 330 0
 1416 0922 7B68     		ldr	r3, [r7, #4]
 1417 0924 9C68     		ldr	r4, [r3, #8]	@ float
 1418 0926 7B68     		ldr	r3, [r7, #4]
 1419 0928 1B68     		ldr	r3, [r3, #0]	@ float
 1420 092a 3868     		ldr	r0, [r7, #0]	@ float
 1421 092c 1946     		mov	r1, r3
 1422 092e FFF7FEFF 		bl	__aeabi_fsub
 1423 0932 0346     		mov	r3, r0
 1424 0934 1D46     		mov	r5, r3
 1425 0936 7B68     		ldr	r3, [r7, #4]
 1426 0938 5B68     		ldr	r3, [r3, #4]	@ float
 1427 093a 3868     		ldr	r0, [r7, #0]	@ float
 1428 093c 1946     		mov	r1, r3
 1429 093e FFF7FEFF 		bl	__aeabi_fsub
 1430 0942 0346     		mov	r3, r0
 1431 0944 2846     		mov	r0, r5
 1432 0946 1946     		mov	r1, r3
 1433 0948 FFF7FEFF 		bl	__aeabi_fmul
 1434 094c 0346     		mov	r3, r0
 1435 094e 2046     		mov	r0, r4
 1436 0950 1946     		mov	r1, r3
 1437 0952 FFF7FEFF 		bl	__aeabi_fadd
 1438 0956 0346     		mov	r3, r0
 1439 0958 1A46     		mov	r2, r3
 1440 095a 7B68     		ldr	r3, [r7, #4]
 1441 095c DA60     		str	r2, [r3, #12]	@ float
 331:../src/sensors.c ****         dev->m_oldM = dev->m_newM;
 1442              		.loc 1 331 0
 1443 095e 7B68     		ldr	r3, [r7, #4]
 1444 0960 5A68     		ldr	r2, [r3, #4]	@ float
 1445 0962 7B68     		ldr	r3, [r7, #4]
 1446 0964 1A60     		str	r2, [r3, #0]	@ float
 332:../src/sensors.c ****         dev->m_oldS = dev->m_newS;
 1447              		.loc 1 332 0
 1448 0966 7B68     		ldr	r3, [r7, #4]
 1449 0968 DA68     		ldr	r2, [r3, #12]	@ float
 1450 096a 7B68     		ldr	r3, [r7, #4]
 1451 096c 9A60     		str	r2, [r3, #8]	@ float
 1452              	.L73:
 333:../src/sensors.c ****     }
 334:../src/sensors.c **** }
 1453              		.loc 1 334 0
 1454 096e 07F10807 		add	r7, r7, #8
 1455 0972 BD46     		mov	sp, r7
 1456 0974 B0BD     		pop	{r4, r5, r7, pc}
 1457              	.L77:
 1458 0976 00BF     		.align	2
 1459              	.L76:
 1460 0978 00000000 		.word	0
 1461              		.cfi_endproc
 1462              	.LFE38:
 1464              		.align	2
 1465              		.thumb
 1466              		.thumb_func
 1468              	devVariance:
 1469              	.LFB39:
 335:../src/sensors.c **** 
 336:../src/sensors.c **** static float devVariance(stdev_t *dev)
 337:../src/sensors.c **** {
 1470              		.loc 1 337 0
 1471              		.cfi_startproc
 1472              		@ args = 0, pretend = 0, frame = 8
 1473              		@ frame_needed = 1, uses_anonymous_args = 0
 1474 097c 90B5     		push	{r4, r7, lr}
 1475              	.LCFI28:
 1476              		.cfi_def_cfa_offset 12
 1477              		.cfi_offset 4, -12
 1478              		.cfi_offset 7, -8
 1479              		.cfi_offset 14, -4
 1480 097e 83B0     		sub	sp, sp, #12
 1481              	.LCFI29:
 1482              		.cfi_def_cfa_offset 24
 1483 0980 00AF     		add	r7, sp, #0
 1484              	.LCFI30:
 1485              		.cfi_def_cfa_register 7
 1486 0982 7860     		str	r0, [r7, #4]
 338:../src/sensors.c ****     return ((dev->m_n > 1) ? dev->m_newS / (dev->m_n - 1) : 0.0f);
 1487              		.loc 1 338 0
 1488 0984 7B68     		ldr	r3, [r7, #4]
 1489 0986 1B69     		ldr	r3, [r3, #16]
 1490 0988 012B     		cmp	r3, #1
 1491 098a 0FDD     		ble	.L79
 1492              		.loc 1 338 0 is_stmt 0 discriminator 1
 1493 098c 7B68     		ldr	r3, [r7, #4]
 1494 098e DC68     		ldr	r4, [r3, #12]	@ float
 1495 0990 7B68     		ldr	r3, [r7, #4]
 1496 0992 1B69     		ldr	r3, [r3, #16]
 1497 0994 03F1FF33 		add	r3, r3, #-1
 1498 0998 1846     		mov	r0, r3
 1499 099a FFF7FEFF 		bl	__aeabi_i2f
 1500 099e 0346     		mov	r3, r0
 1501 09a0 2046     		mov	r0, r4
 1502 09a2 1946     		mov	r1, r3
 1503 09a4 FFF7FEFF 		bl	__aeabi_fdiv
 1504 09a8 0346     		mov	r3, r0
 1505 09aa 00E0     		b	.L80
 1506              	.L79:
 1507              		.loc 1 338 0 discriminator 2
 1508 09ac 024B     		ldr	r3, .L82	@ float
 1509              	.L80:
 339:../src/sensors.c **** }
 1510              		.loc 1 339 0 is_stmt 1 discriminator 3
 1511 09ae 1846     		mov	r0, r3
 1512 09b0 07F10C07 		add	r7, r7, #12
 1513 09b4 BD46     		mov	sp, r7
 1514 09b6 90BD     		pop	{r4, r7, pc}
 1515              	.L83:
 1516              		.align	2
 1517              	.L82:
 1518 09b8 00000000 		.word	0
 1519              		.cfi_endproc
 1520              	.LFE39:
 1522              		.align	2
 1523              		.thumb
 1524              		.thumb_func
 1526              	devStandardDeviation:
 1527              	.LFB40:
 340:../src/sensors.c **** 
 341:../src/sensors.c **** static float devStandardDeviation(stdev_t *dev)
 342:../src/sensors.c **** {
 1528              		.loc 1 342 0
 1529              		.cfi_startproc
 1530              		@ args = 0, pretend = 0, frame = 8
 1531              		@ frame_needed = 1, uses_anonymous_args = 0
 1532 09bc 80B5     		push	{r7, lr}
 1533              	.LCFI31:
 1534              		.cfi_def_cfa_offset 8
 1535              		.cfi_offset 7, -8
 1536              		.cfi_offset 14, -4
 1537 09be 82B0     		sub	sp, sp, #8
 1538              	.LCFI32:
 1539              		.cfi_def_cfa_offset 16
 1540 09c0 00AF     		add	r7, sp, #0
 1541              	.LCFI33:
 1542              		.cfi_def_cfa_register 7
 1543 09c2 7860     		str	r0, [r7, #4]
 343:../src/sensors.c ****     return sqrtf(devVariance(dev));
 1544              		.loc 1 343 0
 1545 09c4 7868     		ldr	r0, [r7, #4]
 1546 09c6 FFF7D9FF 		bl	devVariance
 1547 09ca 0346     		mov	r3, r0
 1548 09cc 1846     		mov	r0, r3
 1549 09ce FFF7FEFF 		bl	sqrtf
 1550 09d2 0346     		mov	r3, r0
 344:../src/sensors.c **** }
 1551              		.loc 1 344 0
 1552 09d4 1846     		mov	r0, r3
 1553 09d6 07F10807 		add	r7, r7, #8
 1554 09da BD46     		mov	sp, r7
 1555 09dc 80BD     		pop	{r7, pc}
 1556              		.cfi_endproc
 1557              	.LFE40:
 1559              		.global	__aeabi_fcmplt
 1560 09de 00BF     		.align	2
 1561              		.thumb
 1562              		.thumb_func
 1564              	GYRO_Common:
 1565              	.LFB41:
 345:../src/sensors.c **** 
 346:../src/sensors.c **** static void GYRO_Common(void)
 347:../src/sensors.c **** {
 1566              		.loc 1 347 0
 1567              		.cfi_startproc
 1568              		@ args = 0, pretend = 0, frame = 8
 1569              		@ frame_needed = 1, uses_anonymous_args = 0
 1570 09e0 90B5     		push	{r4, r7, lr}
 1571              	.LCFI34:
 1572              		.cfi_def_cfa_offset 12
 1573              		.cfi_offset 4, -12
 1574              		.cfi_offset 7, -8
 1575              		.cfi_offset 14, -4
 1576 09e2 83B0     		sub	sp, sp, #12
 1577              	.LCFI35:
 1578              		.cfi_def_cfa_offset 24
 1579 09e4 00AF     		add	r7, sp, #0
 1580              	.LCFI36:
 1581              		.cfi_def_cfa_register 7
 348:../src/sensors.c ****     int axis;
 349:../src/sensors.c ****     static int16_t previousGyroADC[3] = { 0, 0, 0 };
 350:../src/sensors.c ****     static int32_t g[3];
 351:../src/sensors.c ****     static stdev_t var[3];
 352:../src/sensors.c **** 
 353:../src/sensors.c ****     if (calibratingG > 0) {
 1582              		.loc 1 353 0
 1583 09e6 854B     		ldr	r3, .L99
 1584 09e8 1B88     		ldrh	r3, [r3, #0]
 1585 09ea 002B     		cmp	r3, #0
 1586 09ec 00F0B180 		beq	.L87
 354:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 1587              		.loc 1 354 0
 1588 09f0 4FF00003 		mov	r3, #0
 1589 09f4 7B60     		str	r3, [r7, #4]
 1590 09f6 A1E0     		b	.L88
 1591              	.L93:
 355:../src/sensors.c ****             // Reset g[axis] at start of calibration
 356:../src/sensors.c ****             if (calibratingG == 1000) {
 1592              		.loc 1 356 0
 1593 09f8 804B     		ldr	r3, .L99
 1594 09fa 1B88     		ldrh	r3, [r3, #0]
 1595 09fc B3F57A7F 		cmp	r3, #1000
 1596 0a00 11D1     		bne	.L89
 357:../src/sensors.c ****                 g[axis] = 0;
 1597              		.loc 1 357 0
 1598 0a02 7F4B     		ldr	r3, .L99+4
 1599 0a04 7A68     		ldr	r2, [r7, #4]
 1600 0a06 4FF00001 		mov	r1, #0
 1601 0a0a 43F82210 		str	r1, [r3, r2, lsl #2]
 358:../src/sensors.c ****                 devClear(&var[axis]);
 1602              		.loc 1 358 0
 1603 0a0e 7A68     		ldr	r2, [r7, #4]
 1604 0a10 1346     		mov	r3, r2
 1605 0a12 4FEA8303 		lsl	r3, r3, #2
 1606 0a16 9B18     		adds	r3, r3, r2
 1607 0a18 4FEA8303 		lsl	r3, r3, #2
 1608 0a1c 794A     		ldr	r2, .L99+8
 1609 0a1e 9B18     		adds	r3, r3, r2
 1610 0a20 1846     		mov	r0, r3
 1611 0a22 FFF739FF 		bl	devClear
 1612              	.L89:
 359:../src/sensors.c ****             }
 360:../src/sensors.c ****             // Sum up 1000 readings
 361:../src/sensors.c ****             g[axis] += gyroADC[axis];
 1613              		.loc 1 361 0
 1614 0a26 764B     		ldr	r3, .L99+4
 1615 0a28 7A68     		ldr	r2, [r7, #4]
 1616 0a2a 53F82220 		ldr	r2, [r3, r2, lsl #2]
 1617 0a2e 764B     		ldr	r3, .L99+12
 1618 0a30 7968     		ldr	r1, [r7, #4]
 1619 0a32 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 1620 0a36 1BB2     		sxth	r3, r3
 1621 0a38 D118     		adds	r1, r2, r3
 1622 0a3a 714B     		ldr	r3, .L99+4
 1623 0a3c 7A68     		ldr	r2, [r7, #4]
 1624 0a3e 43F82210 		str	r1, [r3, r2, lsl #2]
 362:../src/sensors.c ****             devPush(&var[axis], gyroADC[axis]);
 1625              		.loc 1 362 0
 1626 0a42 7A68     		ldr	r2, [r7, #4]
 1627 0a44 1346     		mov	r3, r2
 1628 0a46 4FEA8303 		lsl	r3, r3, #2
 1629 0a4a 9B18     		adds	r3, r3, r2
 1630 0a4c 4FEA8303 		lsl	r3, r3, #2
 1631 0a50 6C4A     		ldr	r2, .L99+8
 1632 0a52 9C18     		adds	r4, r3, r2
 1633 0a54 6C4B     		ldr	r3, .L99+12
 1634 0a56 7A68     		ldr	r2, [r7, #4]
 1635 0a58 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 1636 0a5c 1BB2     		sxth	r3, r3
 1637 0a5e 1846     		mov	r0, r3
 1638 0a60 FFF7FEFF 		bl	__aeabi_i2f
 1639 0a64 0346     		mov	r3, r0
 1640 0a66 2046     		mov	r0, r4
 1641 0a68 1946     		mov	r1, r3
 1642 0a6a FFF723FF 		bl	devPush
 363:../src/sensors.c ****             // Clear global variables for next reading
 364:../src/sensors.c ****             gyroADC[axis] = 0;
 1643              		.loc 1 364 0
 1644 0a6e 664B     		ldr	r3, .L99+12
 1645 0a70 7A68     		ldr	r2, [r7, #4]
 1646 0a72 4FF00001 		mov	r1, #0
 1647 0a76 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 365:../src/sensors.c ****             gyroZero[axis] = 0;
 1648              		.loc 1 365 0
 1649 0a7a 644B     		ldr	r3, .L99+16
 1650 0a7c 7A68     		ldr	r2, [r7, #4]
 1651 0a7e 4FF00001 		mov	r1, #0
 1652 0a82 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 366:../src/sensors.c ****             if (calibratingG == 1) {
 1653              		.loc 1 366 0
 1654 0a86 5D4B     		ldr	r3, .L99
 1655 0a88 1B88     		ldrh	r3, [r3, #0]
 1656 0a8a 012B     		cmp	r3, #1
 1657 0a8c 52D1     		bne	.L90
 1658              	.LBB4:
 367:../src/sensors.c ****                 float dev = devStandardDeviation(&var[axis]);
 1659              		.loc 1 367 0
 1660 0a8e 7A68     		ldr	r2, [r7, #4]
 1661 0a90 1346     		mov	r3, r2
 1662 0a92 4FEA8303 		lsl	r3, r3, #2
 1663 0a96 9B18     		adds	r3, r3, r2
 1664 0a98 4FEA8303 		lsl	r3, r3, #2
 1665 0a9c 594A     		ldr	r2, .L99+8
 1666 0a9e 9B18     		adds	r3, r3, r2
 1667 0aa0 1846     		mov	r0, r3
 1668 0aa2 FFF78BFF 		bl	devStandardDeviation
 1669 0aa6 3860     		str	r0, [r7, #0]	@ float
 368:../src/sensors.c ****                 // check deviation and startover if idiot was moving the model
 369:../src/sensors.c ****                 if (mcfg.moron_threshold && dev > mcfg.moron_threshold) {
 1670              		.loc 1 369 0
 1671 0aa8 594B     		ldr	r3, .L99+20
 1672 0aaa 93F8EC30 		ldrb	r3, [r3, #236]	@ zero_extendqisi2
 1673 0aae 002B     		cmp	r3, #0
 1674 0ab0 27D0     		beq	.L91
 1675              		.loc 1 369 0 is_stmt 0 discriminator 1
 1676 0ab2 574B     		ldr	r3, .L99+20
 1677 0ab4 93F8EC30 		ldrb	r3, [r3, #236]	@ zero_extendqisi2
 1678 0ab8 1846     		mov	r0, r3
 1679 0aba FFF7FEFF 		bl	__aeabi_i2f
 1680 0abe 0346     		mov	r3, r0
 1681 0ac0 1846     		mov	r0, r3
 1682 0ac2 3968     		ldr	r1, [r7, #0]	@ float
 1683 0ac4 FFF7FEFF 		bl	__aeabi_fcmplt
 1684 0ac8 0346     		mov	r3, r0
 1685 0aca 002B     		cmp	r3, #0
 1686 0acc 19D0     		beq	.L91
 1687              	.L98:
 370:../src/sensors.c ****                     calibratingG = 1000;
 1688              		.loc 1 370 0 is_stmt 1
 1689 0ace 4B4B     		ldr	r3, .L99
 1690 0ad0 4FF47A72 		mov	r2, #1000
 1691 0ad4 1A80     		strh	r2, [r3, #0]	@ movhi
 371:../src/sensors.c ****                     devClear(&var[0]);
 1692              		.loc 1 371 0
 1693 0ad6 4B48     		ldr	r0, .L99+8
 1694 0ad8 FFF7DEFE 		bl	devClear
 372:../src/sensors.c ****                     devClear(&var[1]);
 1695              		.loc 1 372 0
 1696 0adc 4D48     		ldr	r0, .L99+24
 1697 0ade FFF7DBFE 		bl	devClear
 373:../src/sensors.c ****                     devClear(&var[2]);
 1698              		.loc 1 373 0
 1699 0ae2 4D48     		ldr	r0, .L99+28
 1700 0ae4 FFF7D8FE 		bl	devClear
 374:../src/sensors.c ****                     g[0] = g[1] = g[2] = 0;
 1701              		.loc 1 374 0
 1702 0ae8 454B     		ldr	r3, .L99+4
 1703 0aea 4FF00002 		mov	r2, #0
 1704 0aee 9A60     		str	r2, [r3, #8]
 1705 0af0 434B     		ldr	r3, .L99+4
 1706 0af2 9A68     		ldr	r2, [r3, #8]
 1707 0af4 424B     		ldr	r3, .L99+4
 1708 0af6 5A60     		str	r2, [r3, #4]
 1709 0af8 414B     		ldr	r3, .L99+4
 1710 0afa 5A68     		ldr	r2, [r3, #4]
 1711 0afc 404B     		ldr	r3, .L99+4
 1712 0afe 1A60     		str	r2, [r3, #0]
 375:../src/sensors.c ****                     continue;
 1713              		.loc 1 375 0
 1714 0b00 18E0     		b	.L90
 1715              	.L91:
 376:../src/sensors.c ****                 }
 377:../src/sensors.c ****                 gyroZero[axis] = g[axis] / 1000;
 1716              		.loc 1 377 0
 1717 0b02 3F4B     		ldr	r3, .L99+4
 1718 0b04 7A68     		ldr	r2, [r7, #4]
 1719 0b06 53F82230 		ldr	r3, [r3, r2, lsl #2]
 1720 0b0a 444A     		ldr	r2, .L99+32
 1721 0b0c 82FB0312 		smull	r1, r2, r2, r3
 1722 0b10 4FEAA212 		asr	r2, r2, #6
 1723 0b14 4FEAE373 		asr	r3, r3, #31
 1724 0b18 D31A     		subs	r3, r2, r3
 1725 0b1a 99B2     		uxth	r1, r3
 1726 0b1c 3B4B     		ldr	r3, .L99+16
 1727 0b1e 7A68     		ldr	r2, [r7, #4]
 1728 0b20 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 378:../src/sensors.c ****                 blinkLED(10, 15, 1);
 1729              		.loc 1 378 0
 1730 0b24 4FF00A00 		mov	r0, #10
 1731 0b28 4FF00F01 		mov	r1, #15
 1732 0b2c 4FF00102 		mov	r2, #1
 1733 0b30 FFF7FEFF 		bl	blinkLED
 1734              	.L90:
 1735              	.LBE4:
 354:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 1736              		.loc 1 354 0
 1737 0b34 7B68     		ldr	r3, [r7, #4]
 1738 0b36 03F10103 		add	r3, r3, #1
 1739 0b3a 7B60     		str	r3, [r7, #4]
 1740              	.L88:
 354:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 1741              		.loc 1 354 0 is_stmt 0 discriminator 1
 1742 0b3c 7B68     		ldr	r3, [r7, #4]
 1743 0b3e 022B     		cmp	r3, #2
 1744 0b40 7FF75AAF 		ble	.L93
 379:../src/sensors.c ****             }
 380:../src/sensors.c ****         }
 381:../src/sensors.c ****         calibratingG--;
 1745              		.loc 1 381 0 is_stmt 1
 1746 0b44 2D4B     		ldr	r3, .L99
 1747 0b46 1B88     		ldrh	r3, [r3, #0]
 1748 0b48 03F1FF33 		add	r3, r3, #-1
 1749 0b4c 9AB2     		uxth	r2, r3
 1750 0b4e 2B4B     		ldr	r3, .L99
 1751 0b50 1A80     		strh	r2, [r3, #0]	@ movhi
 1752              	.L87:
 382:../src/sensors.c ****     }
 383:../src/sensors.c ****     for (axis = 0; axis < 3; axis++) {
 1753              		.loc 1 383 0
 1754 0b52 4FF00003 		mov	r3, #0
 1755 0b56 7B60     		str	r3, [r7, #4]
 1756 0b58 48E0     		b	.L94
 1757              	.L97:
 384:../src/sensors.c ****         gyroADC[axis] -= gyroZero[axis];
 1758              		.loc 1 384 0
 1759 0b5a 2B4B     		ldr	r3, .L99+12
 1760 0b5c 7A68     		ldr	r2, [r7, #4]
 1761 0b5e 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 1762 0b62 9AB2     		uxth	r2, r3
 1763 0b64 294B     		ldr	r3, .L99+16
 1764 0b66 7968     		ldr	r1, [r7, #4]
 1765 0b68 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 1766 0b6c 9BB2     		uxth	r3, r3
 1767 0b6e D31A     		subs	r3, r2, r3
 1768 0b70 9BB2     		uxth	r3, r3
 1769 0b72 99B2     		uxth	r1, r3
 1770 0b74 244B     		ldr	r3, .L99+12
 1771 0b76 7A68     		ldr	r2, [r7, #4]
 1772 0b78 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 385:../src/sensors.c ****         //anti gyro glitch, limit the variation between two consecutive readings
 386:../src/sensors.c ****         gyroADC[axis] = constrain(gyroADC[axis], previousGyroADC[axis] - 800, previousGyroADC[axis]
 1773              		.loc 1 386 0
 1774 0b7c 224B     		ldr	r3, .L99+12
 1775 0b7e 7A68     		ldr	r2, [r7, #4]
 1776 0b80 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 1777 0b84 1AB2     		sxth	r2, r3
 1778 0b86 264B     		ldr	r3, .L99+36
 1779 0b88 7968     		ldr	r1, [r7, #4]
 1780 0b8a 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 1781 0b8e 1BB2     		sxth	r3, r3
 1782 0b90 A3F54873 		sub	r3, r3, #800
 1783 0b94 9A42     		cmp	r2, r3
 1784 0b96 09DA     		bge	.L95
 1785              		.loc 1 386 0 is_stmt 0 discriminator 1
 1786 0b98 214B     		ldr	r3, .L99+36
 1787 0b9a 7A68     		ldr	r2, [r7, #4]
 1788 0b9c 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 1789 0ba0 9BB2     		uxth	r3, r3
 1790 0ba2 A3F54873 		sub	r3, r3, #800
 1791 0ba6 9BB2     		uxth	r3, r3
 1792 0ba8 9BB2     		uxth	r3, r3
 1793 0baa 0FE0     		b	.L96
 1794              	.L95:
 1795              		.loc 1 386 0 discriminator 2
 1796 0bac 164B     		ldr	r3, .L99+12
 1797 0bae 7A68     		ldr	r2, [r7, #4]
 1798 0bb0 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 1799 0bb4 1AB2     		sxth	r2, r3
 1800 0bb6 1A4B     		ldr	r3, .L99+36
 1801 0bb8 7968     		ldr	r1, [r7, #4]
 1802 0bba 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 1803 0bbe 1BB2     		sxth	r3, r3
 1804 0bc0 03F54873 		add	r3, r3, #800
 1805 0bc4 9A42     		cmp	r2, r3
 1806 0bc6 B8BF     		it	lt
 1807 0bc8 1346     		movlt	r3, r2
 1808 0bca 9BB2     		uxth	r3, r3
 1809              	.L96:
 1810              		.loc 1 386 0 discriminator 3
 1811 0bcc 0E4A     		ldr	r2, .L99+12
 1812 0bce 7968     		ldr	r1, [r7, #4]
 1813 0bd0 22F81130 		strh	r3, [r2, r1, lsl #1]	@ movhi
 387:../src/sensors.c ****         previousGyroADC[axis] = gyroADC[axis];
 1814              		.loc 1 387 0 is_stmt 1 discriminator 3
 1815 0bd4 0C4B     		ldr	r3, .L99+12
 1816 0bd6 7A68     		ldr	r2, [r7, #4]
 1817 0bd8 33F81210 		ldrh	r1, [r3, r2, lsl #1]
 1818 0bdc 104B     		ldr	r3, .L99+36
 1819 0bde 7A68     		ldr	r2, [r7, #4]
 1820 0be0 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 383:../src/sensors.c ****     for (axis = 0; axis < 3; axis++) {
 1821              		.loc 1 383 0 discriminator 3
 1822 0be4 7B68     		ldr	r3, [r7, #4]
 1823 0be6 03F10103 		add	r3, r3, #1
 1824 0bea 7B60     		str	r3, [r7, #4]
 1825              	.L94:
 383:../src/sensors.c ****     for (axis = 0; axis < 3; axis++) {
 1826              		.loc 1 383 0 is_stmt 0 discriminator 1
 1827 0bec 7B68     		ldr	r3, [r7, #4]
 1828 0bee 022B     		cmp	r3, #2
 1829 0bf0 B3DD     		ble	.L97
 388:../src/sensors.c ****     }
 389:../src/sensors.c **** }
 1830              		.loc 1 389 0 is_stmt 1
 1831 0bf2 07F10C07 		add	r7, r7, #12
 1832 0bf6 BD46     		mov	sp, r7
 1833 0bf8 90BD     		pop	{r4, r7, pc}
 1834              	.L100:
 1835 0bfa 00BF     		.align	2
 1836              	.L99:
 1837 0bfc 00000000 		.word	calibratingG
 1838 0c00 20000000 		.word	g.9135
 1839 0c04 2C000000 		.word	var.9136
 1840 0c08 00000000 		.word	gyroADC
 1841 0c0c 00000000 		.word	gyroZero
 1842 0c10 00000000 		.word	mcfg
 1843 0c14 40000000 		.word	var.9136+20
 1844 0c18 54000000 		.word	var.9136+40
 1845 0c1c D34D6210 		.word	274877907
 1846 0c20 68000000 		.word	previousGyroADC.9134
 1847              		.cfi_endproc
 1848              	.LFE41:
 1850              		.align	2
 1851              		.global	Gyro_getADC
 1852              		.thumb
 1853              		.thumb_func
 1855              	Gyro_getADC:
 1856              	.LFB42:
 390:../src/sensors.c **** 
 391:../src/sensors.c **** void Gyro_getADC(void)
 392:../src/sensors.c **** {
 1857              		.loc 1 392 0
 1858              		.cfi_startproc
 1859              		@ args = 0, pretend = 0, frame = 0
 1860              		@ frame_needed = 1, uses_anonymous_args = 0
 1861 0c24 80B5     		push	{r7, lr}
 1862              	.LCFI37:
 1863              		.cfi_def_cfa_offset 8
 1864              		.cfi_offset 7, -8
 1865              		.cfi_offset 14, -4
 1866 0c26 00AF     		add	r7, sp, #0
 1867              	.LCFI38:
 1868              		.cfi_def_cfa_register 7
 393:../src/sensors.c ****     // range: +/- 8192; +/- 2000 deg/sec
 394:../src/sensors.c ****     gyro.read(gyroADC);
 1869              		.loc 1 394 0
 1870 0c28 0A4B     		ldr	r3, .L104
 1871 0c2a 5B68     		ldr	r3, [r3, #4]
 1872 0c2c 0A48     		ldr	r0, .L104+4
 1873 0c2e 9847     		blx	r3
 395:../src/sensors.c ****     // if we have CUSTOM alignment configured, user is "assumed" to know what they're doing
 396:../src/sensors.c ****     if (mcfg.align[ALIGN_GYRO][0])
 1874              		.loc 1 396 0
 1875 0c30 0A4B     		ldr	r3, .L104+8
 1876 0c32 93F8DA30 		ldrb	r3, [r3, #218]	@ zero_extendqisi2
 1877 0c36 002B     		cmp	r3, #0
 1878 0c38 05D0     		beq	.L102
 397:../src/sensors.c ****         alignSensors(ALIGN_GYRO, gyroADC);
 1879              		.loc 1 397 0
 1880 0c3a 4FF00000 		mov	r0, #0
 1881 0c3e 0649     		ldr	r1, .L104+4
 1882 0c40 FFF77CFB 		bl	alignSensors
 1883 0c44 03E0     		b	.L103
 1884              	.L102:
 398:../src/sensors.c ****     else
 399:../src/sensors.c ****         gyro.align(gyroADC);
 1885              		.loc 1 399 0
 1886 0c46 034B     		ldr	r3, .L104
 1887 0c48 9B68     		ldr	r3, [r3, #8]
 1888 0c4a 0348     		ldr	r0, .L104+4
 1889 0c4c 9847     		blx	r3
 1890              	.L103:
 400:../src/sensors.c **** 
 401:../src/sensors.c ****     GYRO_Common();
 1891              		.loc 1 401 0
 1892 0c4e FFF7C7FE 		bl	GYRO_Common
 402:../src/sensors.c **** }
 1893              		.loc 1 402 0
 1894 0c52 80BD     		pop	{r7, pc}
 1895              	.L105:
 1896              		.align	2
 1897              	.L104:
 1898 0c54 00000000 		.word	gyro
 1899 0c58 00000000 		.word	gyroADC
 1900 0c5c 00000000 		.word	mcfg
 1901              		.cfi_endproc
 1902              	.LFE42:
 1904              		.data
 1905 0002 0000     		.align	2
 1908              	magCal:
 1909 0004 0000803F 		.word	1065353216
 1910 0008 0000803F 		.word	1065353216
 1911 000c 0000803F 		.word	1065353216
 1912              		.bss
 1913              	magInit:
 1914 0007 00       		.space	1
 1915              		.text
 1916              		.align	2
 1917              		.thumb
 1918              		.thumb_func
 1920              	Mag_getRawADC:
 1921              	.LFB43:
 403:../src/sensors.c **** 
 404:../src/sensors.c **** #ifdef MAG
 405:../src/sensors.c **** static float magCal[3] = { 1.0, 1.0, 1.0 };     // gain for each axis, populated at sensor init
 406:../src/sensors.c **** static uint8_t magInit = 0;
 407:../src/sensors.c **** 
 408:../src/sensors.c **** static void Mag_getRawADC(void)
 409:../src/sensors.c **** {
 1922              		.loc 1 409 0
 1923              		.cfi_startproc
 1924              		@ args = 0, pretend = 0, frame = 0
 1925              		@ frame_needed = 1, uses_anonymous_args = 0
 1926 0c60 80B5     		push	{r7, lr}
 1927              	.LCFI39:
 1928              		.cfi_def_cfa_offset 8
 1929              		.cfi_offset 7, -8
 1930              		.cfi_offset 14, -4
 1931 0c62 00AF     		add	r7, sp, #0
 1932              	.LCFI40:
 1933              		.cfi_def_cfa_register 7
 410:../src/sensors.c ****     hmc5883lRead(magADC);
 1934              		.loc 1 410 0
 1935 0c64 0448     		ldr	r0, .L107
 1936 0c66 FFF7FEFF 		bl	hmc5883lRead
 411:../src/sensors.c **** 
 412:../src/sensors.c ****     // Default mag orientation is -2, -3, 1 or
 413:../src/sensors.c ****     // no way? is THIS finally the proper orientation?? (by GrootWitBaas)
 414:../src/sensors.c ****     // magADC[ROLL] = rawADC[2]; // X
 415:../src/sensors.c ****     // magADC[PITCH] = -rawADC[0]; // Y
 416:../src/sensors.c ****     // magADC[YAW] = -rawADC[1]; // Z
 417:../src/sensors.c ****     alignSensors(ALIGN_MAG, magADC);
 1937              		.loc 1 417 0
 1938 0c6a 4FF00200 		mov	r0, #2
 1939 0c6e 0249     		ldr	r1, .L107
 1940 0c70 FFF764FB 		bl	alignSensors
 418:../src/sensors.c **** }
 1941              		.loc 1 418 0
 1942 0c74 80BD     		pop	{r7, pc}
 1943              	.L108:
 1944 0c76 00BF     		.align	2
 1945              	.L107:
 1946 0c78 00000000 		.word	magADC
 1947              		.cfi_endproc
 1948              	.LFE43:
 1950              		.align	2
 1951              		.global	Mag_init
 1952              		.thumb
 1953              		.thumb_func
 1955              	Mag_init:
 1956              	.LFB44:
 419:../src/sensors.c **** 
 420:../src/sensors.c **** void Mag_init(void)
 421:../src/sensors.c **** {
 1957              		.loc 1 421 0
 1958              		.cfi_startproc
 1959              		@ args = 0, pretend = 0, frame = 0
 1960              		@ frame_needed = 1, uses_anonymous_args = 0
 1961 0c7c 80B5     		push	{r7, lr}
 1962              	.LCFI41:
 1963              		.cfi_def_cfa_offset 8
 1964              		.cfi_offset 7, -8
 1965              		.cfi_offset 14, -4
 1966 0c7e 00AF     		add	r7, sp, #0
 1967              	.LCFI42:
 1968              		.cfi_def_cfa_register 7
 422:../src/sensors.c ****     // initialize and calibration. turn on led during mag calibration (calibration routine blinks i
 423:../src/sensors.c ****     LED1_ON;
 1969              		.loc 1 423 0
 1970 0c80 074B     		ldr	r3, .L110
 1971 0c82 4FF01002 		mov	r2, #16
 1972 0c86 5A61     		str	r2, [r3, #20]
 424:../src/sensors.c ****     hmc5883lInit(magCal);
 1973              		.loc 1 424 0
 1974 0c88 0648     		ldr	r0, .L110+4
 1975 0c8a FFF7FEFF 		bl	hmc5883lInit
 425:../src/sensors.c ****     LED1_OFF;
 1976              		.loc 1 425 0
 1977 0c8e 044B     		ldr	r3, .L110
 1978 0c90 4FF01002 		mov	r2, #16
 1979 0c94 1A61     		str	r2, [r3, #16]
 426:../src/sensors.c ****     magInit = 1;
 1980              		.loc 1 426 0
 1981 0c96 044B     		ldr	r3, .L110+8
 1982 0c98 4FF00102 		mov	r2, #1
 1983 0c9c 1A70     		strb	r2, [r3, #0]
 427:../src/sensors.c **** }
 1984              		.loc 1 427 0
 1985 0c9e 80BD     		pop	{r7, pc}
 1986              	.L111:
 1987              		.align	2
 1988              	.L110:
 1989 0ca0 000C0140 		.word	1073810432
 1990 0ca4 04000000 		.word	magCal
 1991 0ca8 07000000 		.word	magInit
 1992              		.cfi_endproc
 1993              	.LFE44:
 1995              		.global	__aeabi_f2iz
 1996              		.align	2
 1997              		.global	Mag_getADC
 1998              		.thumb
 1999              		.thumb_func
 2001              	Mag_getADC:
 2002              	.LFB45:
 428:../src/sensors.c **** 
 429:../src/sensors.c **** int Mag_getADC(void)
 430:../src/sensors.c **** {
 2003              		.loc 1 430 0
 2004              		.cfi_startproc
 2005              		@ args = 0, pretend = 0, frame = 8
 2006              		@ frame_needed = 1, uses_anonymous_args = 0
 2007 0cac 80B5     		push	{r7, lr}
 2008              	.LCFI43:
 2009              		.cfi_def_cfa_offset 8
 2010              		.cfi_offset 7, -8
 2011              		.cfi_offset 14, -4
 2012 0cae 82B0     		sub	sp, sp, #8
 2013              	.LCFI44:
 2014              		.cfi_def_cfa_offset 16
 2015 0cb0 00AF     		add	r7, sp, #0
 2016              	.LCFI45:
 2017              		.cfi_def_cfa_register 7
 431:../src/sensors.c ****     static uint32_t t, tCal = 0;
 432:../src/sensors.c ****     static int16_t magZeroTempMin[3];
 433:../src/sensors.c ****     static int16_t magZeroTempMax[3];
 434:../src/sensors.c ****     uint32_t axis;
 435:../src/sensors.c **** 
 436:../src/sensors.c ****     if ((int32_t)(currentTime - t) < 0)
 2018              		.loc 1 436 0
 2019 0cb2 7D4B     		ldr	r3, .L127
 2020 0cb4 1A68     		ldr	r2, [r3, #0]
 2021 0cb6 7D4B     		ldr	r3, .L127+4
 2022 0cb8 1B68     		ldr	r3, [r3, #0]
 2023 0cba D31A     		subs	r3, r2, r3
 2024 0cbc 002B     		cmp	r3, #0
 2025 0cbe 02DA     		bge	.L113
 437:../src/sensors.c ****         return 0;                 //each read is spaced by 100ms
 2026              		.loc 1 437 0
 2027 0cc0 4FF00003 		mov	r3, #0
 2028 0cc4 30E1     		b	.L114
 2029              	.L113:
 438:../src/sensors.c ****     t = currentTime + 100000;
 2030              		.loc 1 438 0
 2031 0cc6 784B     		ldr	r3, .L127
 2032 0cc8 1B68     		ldr	r3, [r3, #0]
 2033 0cca 03F5C333 		add	r3, r3, #99840
 2034 0cce 03F1A003 		add	r3, r3, #160
 2035 0cd2 764A     		ldr	r2, .L127+4
 2036 0cd4 1360     		str	r3, [r2, #0]
 439:../src/sensors.c **** 
 440:../src/sensors.c ****     // Read mag sensor
 441:../src/sensors.c ****     Mag_getRawADC();
 2037              		.loc 1 441 0
 2038 0cd6 FFF7C3FF 		bl	Mag_getRawADC
 442:../src/sensors.c **** 
 443:../src/sensors.c ****     magADC[ROLL]  = magADC[ROLL]  * magCal[ROLL];
 2039              		.loc 1 443 0
 2040 0cda 754B     		ldr	r3, .L127+8
 2041 0cdc 1B88     		ldrh	r3, [r3, #0]
 2042 0cde 1BB2     		sxth	r3, r3
 2043 0ce0 1846     		mov	r0, r3
 2044 0ce2 FFF7FEFF 		bl	__aeabi_i2f
 2045 0ce6 0246     		mov	r2, r0
 2046 0ce8 724B     		ldr	r3, .L127+12
 2047 0cea 1B68     		ldr	r3, [r3, #0]	@ float
 2048 0cec 1046     		mov	r0, r2
 2049 0cee 1946     		mov	r1, r3
 2050 0cf0 FFF7FEFF 		bl	__aeabi_fmul
 2051 0cf4 0346     		mov	r3, r0
 2052 0cf6 1846     		mov	r0, r3
 2053 0cf8 FFF7FEFF 		bl	__aeabi_f2iz
 2054 0cfc 0346     		mov	r3, r0
 2055 0cfe 9AB2     		uxth	r2, r3
 2056 0d00 6B4B     		ldr	r3, .L127+8
 2057 0d02 1A80     		strh	r2, [r3, #0]	@ movhi
 444:../src/sensors.c ****     magADC[PITCH] = magADC[PITCH] * magCal[PITCH];
 2058              		.loc 1 444 0
 2059 0d04 6A4B     		ldr	r3, .L127+8
 2060 0d06 5B88     		ldrh	r3, [r3, #2]
 2061 0d08 1BB2     		sxth	r3, r3
 2062 0d0a 1846     		mov	r0, r3
 2063 0d0c FFF7FEFF 		bl	__aeabi_i2f
 2064 0d10 0246     		mov	r2, r0
 2065 0d12 684B     		ldr	r3, .L127+12
 2066 0d14 5B68     		ldr	r3, [r3, #4]	@ float
 2067 0d16 1046     		mov	r0, r2
 2068 0d18 1946     		mov	r1, r3
 2069 0d1a FFF7FEFF 		bl	__aeabi_fmul
 2070 0d1e 0346     		mov	r3, r0
 2071 0d20 1846     		mov	r0, r3
 2072 0d22 FFF7FEFF 		bl	__aeabi_f2iz
 2073 0d26 0346     		mov	r3, r0
 2074 0d28 9AB2     		uxth	r2, r3
 2075 0d2a 614B     		ldr	r3, .L127+8
 2076 0d2c 5A80     		strh	r2, [r3, #2]	@ movhi
 445:../src/sensors.c ****     magADC[YAW]   = magADC[YAW]   * magCal[YAW];
 2077              		.loc 1 445 0
 2078 0d2e 604B     		ldr	r3, .L127+8
 2079 0d30 9B88     		ldrh	r3, [r3, #4]
 2080 0d32 1BB2     		sxth	r3, r3
 2081 0d34 1846     		mov	r0, r3
 2082 0d36 FFF7FEFF 		bl	__aeabi_i2f
 2083 0d3a 0246     		mov	r2, r0
 2084 0d3c 5D4B     		ldr	r3, .L127+12
 2085 0d3e 9B68     		ldr	r3, [r3, #8]	@ float
 2086 0d40 1046     		mov	r0, r2
 2087 0d42 1946     		mov	r1, r3
 2088 0d44 FFF7FEFF 		bl	__aeabi_fmul
 2089 0d48 0346     		mov	r3, r0
 2090 0d4a 1846     		mov	r0, r3
 2091 0d4c FFF7FEFF 		bl	__aeabi_f2iz
 2092 0d50 0346     		mov	r3, r0
 2093 0d52 9AB2     		uxth	r2, r3
 2094 0d54 564B     		ldr	r3, .L127+8
 2095 0d56 9A80     		strh	r2, [r3, #4]	@ movhi
 446:../src/sensors.c **** 
 447:../src/sensors.c ****     if (f.CALIBRATE_MAG) {
 2096              		.loc 1 447 0
 2097 0d58 574B     		ldr	r3, .L127+16
 2098 0d5a 9B7B     		ldrb	r3, [r3, #14]	@ zero_extendqisi2
 2099 0d5c 002B     		cmp	r3, #0
 2100 0d5e 2CD0     		beq	.L115
 448:../src/sensors.c ****         tCal = t;
 2101              		.loc 1 448 0
 2102 0d60 524B     		ldr	r3, .L127+4
 2103 0d62 1A68     		ldr	r2, [r3, #0]
 2104 0d64 554B     		ldr	r3, .L127+20
 2105 0d66 1A60     		str	r2, [r3, #0]
 449:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 2106              		.loc 1 449 0
 2107 0d68 4FF00003 		mov	r3, #0
 2108 0d6c 7B60     		str	r3, [r7, #4]
 2109 0d6e 1DE0     		b	.L116
 2110              	.L117:
 450:../src/sensors.c ****             mcfg.magZero[axis] = 0;
 2111              		.loc 1 450 0 discriminator 2
 2112 0d70 534A     		ldr	r2, .L127+24
 2113 0d72 7B68     		ldr	r3, [r7, #4]
 2114 0d74 03F17803 		add	r3, r3, #120
 2115 0d78 4FEA4303 		lsl	r3, r3, #1
 2116 0d7c D318     		adds	r3, r2, r3
 2117 0d7e 4FF00002 		mov	r2, #0
 2118 0d82 9A80     		strh	r2, [r3, #4]	@ movhi
 451:../src/sensors.c ****             magZeroTempMin[axis] = magADC[axis];
 2119              		.loc 1 451 0 discriminator 2
 2120 0d84 4A4B     		ldr	r3, .L127+8
 2121 0d86 7A68     		ldr	r2, [r7, #4]
 2122 0d88 33F81210 		ldrh	r1, [r3, r2, lsl #1]
 2123 0d8c 4D4B     		ldr	r3, .L127+28
 2124 0d8e 7A68     		ldr	r2, [r7, #4]
 2125 0d90 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 452:../src/sensors.c ****             magZeroTempMax[axis] = magADC[axis];
 2126              		.loc 1 452 0 discriminator 2
 2127 0d94 464B     		ldr	r3, .L127+8
 2128 0d96 7A68     		ldr	r2, [r7, #4]
 2129 0d98 33F81210 		ldrh	r1, [r3, r2, lsl #1]
 2130 0d9c 4A4B     		ldr	r3, .L127+32
 2131 0d9e 7A68     		ldr	r2, [r7, #4]
 2132 0da0 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 449:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 2133              		.loc 1 449 0 discriminator 2
 2134 0da4 7B68     		ldr	r3, [r7, #4]
 2135 0da6 03F10103 		add	r3, r3, #1
 2136 0daa 7B60     		str	r3, [r7, #4]
 2137              	.L116:
 449:../src/sensors.c ****         for (axis = 0; axis < 3; axis++) {
 2138              		.loc 1 449 0 is_stmt 0 discriminator 1
 2139 0dac 7B68     		ldr	r3, [r7, #4]
 2140 0dae 022B     		cmp	r3, #2
 2141 0db0 DED9     		bls	.L117
 453:../src/sensors.c ****         }
 454:../src/sensors.c ****         f.CALIBRATE_MAG = 0;
 2142              		.loc 1 454 0 is_stmt 1
 2143 0db2 414B     		ldr	r3, .L127+16
 2144 0db4 4FF00002 		mov	r2, #0
 2145 0db8 9A73     		strb	r2, [r3, #14]
 2146              	.L115:
 455:../src/sensors.c ****     }
 456:../src/sensors.c **** 
 457:../src/sensors.c ****     if (magInit) {              // we apply offset only once mag calibration is done
 2147              		.loc 1 457 0
 2148 0dba 444B     		ldr	r3, .L127+36
 2149 0dbc 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2150 0dbe 002B     		cmp	r3, #0
 2151 0dc0 23D0     		beq	.L118
 458:../src/sensors.c ****         magADC[ROLL] -= mcfg.magZero[ROLL];
 2152              		.loc 1 458 0
 2153 0dc2 3B4B     		ldr	r3, .L127+8
 2154 0dc4 1B88     		ldrh	r3, [r3, #0]
 2155 0dc6 9AB2     		uxth	r2, r3
 2156 0dc8 3D4B     		ldr	r3, .L127+24
 2157 0dca B3F8F430 		ldrh	r3, [r3, #244]
 2158 0dce 9BB2     		uxth	r3, r3
 2159 0dd0 D31A     		subs	r3, r2, r3
 2160 0dd2 9BB2     		uxth	r3, r3
 2161 0dd4 9AB2     		uxth	r2, r3
 2162 0dd6 364B     		ldr	r3, .L127+8
 2163 0dd8 1A80     		strh	r2, [r3, #0]	@ movhi
 459:../src/sensors.c ****         magADC[PITCH] -= mcfg.magZero[PITCH];
 2164              		.loc 1 459 0
 2165 0dda 354B     		ldr	r3, .L127+8
 2166 0ddc 5B88     		ldrh	r3, [r3, #2]
 2167 0dde 9AB2     		uxth	r2, r3
 2168 0de0 374B     		ldr	r3, .L127+24
 2169 0de2 B3F8F630 		ldrh	r3, [r3, #246]
 2170 0de6 9BB2     		uxth	r3, r3
 2171 0de8 D31A     		subs	r3, r2, r3
 2172 0dea 9BB2     		uxth	r3, r3
 2173 0dec 9AB2     		uxth	r2, r3
 2174 0dee 304B     		ldr	r3, .L127+8
 2175 0df0 5A80     		strh	r2, [r3, #2]	@ movhi
 460:../src/sensors.c ****         magADC[YAW] -= mcfg.magZero[YAW];
 2176              		.loc 1 460 0
 2177 0df2 2F4B     		ldr	r3, .L127+8
 2178 0df4 9B88     		ldrh	r3, [r3, #4]
 2179 0df6 9AB2     		uxth	r2, r3
 2180 0df8 314B     		ldr	r3, .L127+24
 2181 0dfa B3F8F830 		ldrh	r3, [r3, #248]
 2182 0dfe 9BB2     		uxth	r3, r3
 2183 0e00 D31A     		subs	r3, r2, r3
 2184 0e02 9BB2     		uxth	r3, r3
 2185 0e04 9AB2     		uxth	r2, r3
 2186 0e06 2A4B     		ldr	r3, .L127+8
 2187 0e08 9A80     		strh	r2, [r3, #4]	@ movhi
 2188              	.L118:
 461:../src/sensors.c ****     }
 462:../src/sensors.c **** 
 463:../src/sensors.c ****     if (tCal != 0) {
 2189              		.loc 1 463 0
 2190 0e0a 2C4B     		ldr	r3, .L127+20
 2191 0e0c 1B68     		ldr	r3, [r3, #0]
 2192 0e0e 002B     		cmp	r3, #0
 2193 0e10 00F08880 		beq	.L119
 464:../src/sensors.c ****         if ((t - tCal) < 30000000) {    // 30s: you have 30s to turn the multi in all directions
 2194              		.loc 1 464 0
 2195 0e14 254B     		ldr	r3, .L127+4
 2196 0e16 1A68     		ldr	r2, [r3, #0]
 2197 0e18 284B     		ldr	r3, .L127+20
 2198 0e1a 1B68     		ldr	r3, [r3, #0]
 2199 0e1c D21A     		subs	r2, r2, r3
 2200 0e1e 2C4B     		ldr	r3, .L127+40
 2201 0e20 9A42     		cmp	r2, r3
 2202 0e22 39D8     		bhi	.L120
 465:../src/sensors.c ****             LED0_TOGGLE;
 2203              		.loc 1 465 0
 2204 0e24 2B4B     		ldr	r3, .L127+44
 2205 0e26 2B4A     		ldr	r2, .L127+44
 2206 0e28 D268     		ldr	r2, [r2, #12]
 2207 0e2a 82F00802 		eor	r2, r2, #8
 2208 0e2e DA60     		str	r2, [r3, #12]
 466:../src/sensors.c ****             for (axis = 0; axis < 3; axis++) {
 2209              		.loc 1 466 0
 2210 0e30 4FF00003 		mov	r3, #0
 2211 0e34 7B60     		str	r3, [r7, #4]
 2212 0e36 2BE0     		b	.L121
 2213              	.L124:
 467:../src/sensors.c ****                 if (magADC[axis] < magZeroTempMin[axis])
 2214              		.loc 1 467 0
 2215 0e38 1D4B     		ldr	r3, .L127+8
 2216 0e3a 7A68     		ldr	r2, [r7, #4]
 2217 0e3c 33F81220 		ldrh	r2, [r3, r2, lsl #1]
 2218 0e40 204B     		ldr	r3, .L127+28
 2219 0e42 7968     		ldr	r1, [r7, #4]
 2220 0e44 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 2221 0e48 12B2     		sxth	r2, r2
 2222 0e4a 1BB2     		sxth	r3, r3
 2223 0e4c 9A42     		cmp	r2, r3
 2224 0e4e 07DA     		bge	.L122
 468:../src/sensors.c ****                     magZeroTempMin[axis] = magADC[axis];
 2225              		.loc 1 468 0
 2226 0e50 174B     		ldr	r3, .L127+8
 2227 0e52 7A68     		ldr	r2, [r7, #4]
 2228 0e54 33F81210 		ldrh	r1, [r3, r2, lsl #1]
 2229 0e58 1A4B     		ldr	r3, .L127+28
 2230 0e5a 7A68     		ldr	r2, [r7, #4]
 2231 0e5c 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 2232              	.L122:
 469:../src/sensors.c ****                 if (magADC[axis] > magZeroTempMax[axis])
 2233              		.loc 1 469 0
 2234 0e60 134B     		ldr	r3, .L127+8
 2235 0e62 7A68     		ldr	r2, [r7, #4]
 2236 0e64 33F81220 		ldrh	r2, [r3, r2, lsl #1]
 2237 0e68 174B     		ldr	r3, .L127+32
 2238 0e6a 7968     		ldr	r1, [r7, #4]
 2239 0e6c 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 2240 0e70 12B2     		sxth	r2, r2
 2241 0e72 1BB2     		sxth	r3, r3
 2242 0e74 9A42     		cmp	r2, r3
 2243 0e76 07DD     		ble	.L123
 470:../src/sensors.c ****                     magZeroTempMax[axis] = magADC[axis];
 2244              		.loc 1 470 0
 2245 0e78 0D4B     		ldr	r3, .L127+8
 2246 0e7a 7A68     		ldr	r2, [r7, #4]
 2247 0e7c 33F81210 		ldrh	r1, [r3, r2, lsl #1]
 2248 0e80 114B     		ldr	r3, .L127+32
 2249 0e82 7A68     		ldr	r2, [r7, #4]
 2250 0e84 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 2251              	.L123:
 466:../src/sensors.c ****             for (axis = 0; axis < 3; axis++) {
 2252              		.loc 1 466 0
 2253 0e88 7B68     		ldr	r3, [r7, #4]
 2254 0e8a 03F10103 		add	r3, r3, #1
 2255 0e8e 7B60     		str	r3, [r7, #4]
 2256              	.L121:
 466:../src/sensors.c ****             for (axis = 0; axis < 3; axis++) {
 2257              		.loc 1 466 0 is_stmt 0 discriminator 1
 2258 0e90 7B68     		ldr	r3, [r7, #4]
 2259 0e92 022B     		cmp	r3, #2
 2260 0e94 D0D9     		bls	.L124
 466:../src/sensors.c ****             for (axis = 0; axis < 3; axis++) {
 2261              		.loc 1 466 0
 2262 0e96 45E0     		b	.L119
 2263              	.L120:
 471:../src/sensors.c ****             }
 472:../src/sensors.c ****         } else {
 473:../src/sensors.c ****             tCal = 0;
 2264              		.loc 1 473 0 is_stmt 1
 2265 0e98 084B     		ldr	r3, .L127+20
 2266 0e9a 4FF00002 		mov	r2, #0
 2267 0e9e 1A60     		str	r2, [r3, #0]
 474:../src/sensors.c ****             for (axis = 0; axis < 3; axis++)
 2268              		.loc 1 474 0
 2269 0ea0 4FF00003 		mov	r3, #0
 2270 0ea4 7B60     		str	r3, [r7, #4]
 2271 0ea6 34E0     		b	.L125
 2272              	.L128:
 2273              		.align	2
 2274              	.L127:
 2275 0ea8 00000000 		.word	currentTime
 2276 0eac 08000000 		.word	t.9159
 2277 0eb0 00000000 		.word	magADC
 2278 0eb4 04000000 		.word	magCal
 2279 0eb8 00000000 		.word	f
 2280 0ebc 0C000000 		.word	tCal.9160
 2281 0ec0 00000000 		.word	mcfg
 2282 0ec4 10000000 		.word	magZeroTempMin.9161
 2283 0ec8 18000000 		.word	magZeroTempMax.9162
 2284 0ecc 07000000 		.word	magInit
 2285 0ed0 7FC3C901 		.word	29999999
 2286 0ed4 000C0140 		.word	1073810432
 2287              	.L126:
 475:../src/sensors.c ****                 mcfg.magZero[axis] = (magZeroTempMin[axis] + magZeroTempMax[axis]) / 2; // Calculat
 2288              		.loc 1 475 0 discriminator 2
 2289 0ed8 164B     		ldr	r3, .L129
 2290 0eda 7A68     		ldr	r2, [r7, #4]
 2291 0edc 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 2292 0ee0 1AB2     		sxth	r2, r3
 2293 0ee2 154B     		ldr	r3, .L129+4
 2294 0ee4 7968     		ldr	r1, [r7, #4]
 2295 0ee6 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 2296 0eea 1BB2     		sxth	r3, r3
 2297 0eec D318     		adds	r3, r2, r3
 2298 0eee 4FEAD372 		lsr	r2, r3, #31
 2299 0ef2 D318     		adds	r3, r2, r3
 2300 0ef4 4FEA6303 		asr	r3, r3, #1
 2301 0ef8 9AB2     		uxth	r2, r3
 2302 0efa 1049     		ldr	r1, .L129+8
 2303 0efc 7B68     		ldr	r3, [r7, #4]
 2304 0efe 03F17803 		add	r3, r3, #120
 2305 0f02 4FEA4303 		lsl	r3, r3, #1
 2306 0f06 CB18     		adds	r3, r1, r3
 2307 0f08 9A80     		strh	r2, [r3, #4]	@ movhi
 474:../src/sensors.c ****             for (axis = 0; axis < 3; axis++)
 2308              		.loc 1 474 0 discriminator 2
 2309 0f0a 7B68     		ldr	r3, [r7, #4]
 2310 0f0c 03F10103 		add	r3, r3, #1
 2311 0f10 7B60     		str	r3, [r7, #4]
 2312              	.L125:
 474:../src/sensors.c ****             for (axis = 0; axis < 3; axis++)
 2313              		.loc 1 474 0 is_stmt 0 discriminator 1
 2314 0f12 7B68     		ldr	r3, [r7, #4]
 2315 0f14 022B     		cmp	r3, #2
 2316 0f16 DFD9     		bls	.L126
 476:../src/sensors.c ****             writeEEPROM(1, true);
 2317              		.loc 1 476 0 is_stmt 1
 2318 0f18 4FF00100 		mov	r0, #1
 2319 0f1c 4FF00101 		mov	r1, #1
 2320 0f20 FFF7FEFF 		bl	writeEEPROM
 2321              	.L119:
 477:../src/sensors.c ****         }
 478:../src/sensors.c ****     }
 479:../src/sensors.c ****     
 480:../src/sensors.c ****     return 1;
 2322              		.loc 1 480 0
 2323 0f24 4FF00103 		mov	r3, #1
 2324              	.L114:
 481:../src/sensors.c **** }
 2325              		.loc 1 481 0
 2326 0f28 1846     		mov	r0, r3
 2327 0f2a 07F10807 		add	r7, r7, #8
 2328 0f2e BD46     		mov	sp, r7
 2329 0f30 80BD     		pop	{r7, pc}
 2330              	.L130:
 2331 0f32 00BF     		.align	2
 2332              	.L129:
 2333 0f34 10000000 		.word	magZeroTempMin.9161
 2334 0f38 18000000 		.word	magZeroTempMax.9162
 2335 0f3c 00000000 		.word	mcfg
 2336              		.cfi_endproc
 2337              	.LFE45:
 2339              		.align	2
 2340              		.global	Sonar_init
 2341              		.thumb
 2342              		.thumb_func
 2344              	Sonar_init:
 2345              	.LFB46:
 482:../src/sensors.c **** #endif
 483:../src/sensors.c **** 
 484:../src/sensors.c **** #ifdef SONAR
 485:../src/sensors.c **** 
 486:../src/sensors.c **** void Sonar_init(void) 
 487:../src/sensors.c **** {
 2346              		.loc 1 487 0
 2347              		.cfi_startproc
 2348              		@ args = 0, pretend = 0, frame = 0
 2349              		@ frame_needed = 1, uses_anonymous_args = 0
 2350 0f40 80B5     		push	{r7, lr}
 2351              	.LCFI46:
 2352              		.cfi_def_cfa_offset 8
 2353              		.cfi_offset 7, -8
 2354              		.cfi_offset 14, -4
 2355 0f42 00AF     		add	r7, sp, #0
 2356              	.LCFI47:
 2357              		.cfi_def_cfa_register 7
 488:../src/sensors.c ****     hcsr04_init(sonar_rc78);
 2358              		.loc 1 488 0
 2359 0f44 4FF00100 		mov	r0, #1
 2360 0f48 FFF7FEFF 		bl	hcsr04_init
 489:../src/sensors.c ****     sensorsSet(SENSOR_SONAR);
 2361              		.loc 1 489 0
 2362 0f4c 4FF00800 		mov	r0, #8
 2363 0f50 FFF7FEFF 		bl	sensorsSet
 490:../src/sensors.c ****     sonarAlt = 0;
 2364              		.loc 1 490 0
 2365 0f54 024B     		ldr	r3, .L132
 2366 0f56 4FF00002 		mov	r2, #0
 2367 0f5a 1A80     		strh	r2, [r3, #0]	@ movhi
 491:../src/sensors.c **** }
 2368              		.loc 1 491 0
 2369 0f5c 80BD     		pop	{r7, pc}
 2370              	.L133:
 2371 0f5e 00BF     		.align	2
 2372              	.L132:
 2373 0f60 00000000 		.word	sonarAlt
 2374              		.cfi_endproc
 2375              	.LFE46:
 2377              		.align	2
 2378              		.global	Sonar_update
 2379              		.thumb
 2380              		.thumb_func
 2382              	Sonar_update:
 2383              	.LFB47:
 492:../src/sensors.c **** 
 493:../src/sensors.c **** void Sonar_update(void) 
 494:../src/sensors.c **** {
 2384              		.loc 1 494 0
 2385              		.cfi_startproc
 2386              		@ args = 0, pretend = 0, frame = 0
 2387              		@ frame_needed = 1, uses_anonymous_args = 0
 2388 0f64 80B5     		push	{r7, lr}
 2389              	.LCFI48:
 2390              		.cfi_def_cfa_offset 8
 2391              		.cfi_offset 7, -8
 2392              		.cfi_offset 14, -4
 2393 0f66 00AF     		add	r7, sp, #0
 2394              	.LCFI49:
 2395              		.cfi_def_cfa_register 7
 495:../src/sensors.c ****     hcsr04_get_distance(&sonarAlt);
 2396              		.loc 1 495 0
 2397 0f68 0148     		ldr	r0, .L135
 2398 0f6a FFF7FEFF 		bl	hcsr04_get_distance
 496:../src/sensors.c **** }
 2399              		.loc 1 496 0
 2400 0f6e 80BD     		pop	{r7, pc}
 2401              	.L136:
 2402              		.align	2
 2403              	.L135:
 2404 0f70 00000000 		.word	sonarAlt
 2405              		.cfi_endproc
 2406              	.LFE47:
 2408              		.bss
 2409              		.align	2
 2410              	t.9159:
 2411 0008 00000000 		.space	4
 2412              		.align	2
 2413              	tCal.9160:
 2414 000c 00000000 		.space	4
 2415              		.align	2
 2416              	magZeroTempMin.9161:
 2417 0010 00000000 		.space	6
 2417      0000
 2418 0016 0000     		.align	2
 2419              	magZeroTempMax.9162:
 2420 0018 00000000 		.space	6
 2420      0000
 2421 001e 0000     		.align	2
 2422              	g.9135:
 2423 0020 00000000 		.space	12
 2423      00000000 
 2423      00000000 
 2424              		.align	2
 2425              	var.9136:
 2426 002c 00000000 		.space	60
 2426      00000000 
 2426      00000000 
 2426      00000000 
 2426      00000000 
 2427              		.align	2
 2428              	previousGyroADC.9134:
 2429 0068 00000000 		.space	6
 2429      0000
 2430 006e 0000     		.align	2
 2431              	baroDeadline.9108:
 2432 0070 00000000 		.space	4
 2433              		.align	2
 2434              	state.9109:
 2435 0074 00000000 		.space	4
 2436              		.align	2
 2437              	baroHistIdx.9103:
 2438 0078 00000000 		.space	4
 2439              		.align	2
 2440              	baroHistTab.9102:
 2441 007c 00000000 		.space	192
 2441      00000000 
 2441      00000000 
 2441      00000000 
 2441      00000000 
 2442              		.align	2
 2443              	a.9085:
 2444 013c 00000000 		.space	12
 2444      00000000 
 2444      00000000 
 2445              		.align	2
 2446              	accZero_saved.9091:
 2447 0148 00000000 		.space	6
 2447      0000
 2448 014e 0000     		.align	2
 2449              	angleTrim_saved.9092:
 2450 0150 00000000 		.space	4
 2451              		.align	2
 2452              	b.9090:
 2453 0154 00000000 		.space	12
 2453      00000000 
 2453      00000000 
 2454              		.text
 2455              	.Letext0:
 2456              		.file 2 "/home/oni/ARM_EABI/bin/../lib/gcc/arm-none-eabi/4.7.2/../../../../arm-none-eabi/include/s
 2457              		.file 3 "/home/oni/workspace/Naze32/lib/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h"
 2458              		.file 4 "../src/board.h"
 2459              		.file 5 "../src/drv_adxl345.h"
 2460              		.file 6 "../src/drv_hcsr04.h"
 2461              		.file 7 "../src/mw.h"
 2462              		.file 8 "/home/oni/workspace/Naze32/lib/CMSIS/CM3/CoreSupport/core_cm3.h"
DEFINED SYMBOLS
                            *ABS*:00000000 sensors.c
     /tmp/ccwPP4Q6.s:23     .bss:00000000 calibratingA
     /tmp/ccwPP4Q6.s:20     .bss:00000000 $d
     /tmp/ccwPP4Q6.s:29     .bss:00000002 calibratingB
     /tmp/ccwPP4Q6.s:35     .bss:00000004 calibratingG
     /tmp/ccwPP4Q6.s:42     .data:00000000 acc_1G
     /tmp/ccwPP4Q6.s:39     .data:00000000 $d
                            *COM*:00000002 heading
                            *COM*:00000002 magHold
                            *COM*:00000014 acc
                            *COM*:00000014 gyro
                            *COM*:00000018 baro
     /tmp/ccwPP4Q6.s:53     .bss:00000006 accHardware
     /tmp/ccwPP4Q6.s:59     .text:00000000 $t
     /tmp/ccwPP4Q6.s:64     .text:00000000 sensorsAutodetect
     /tmp/ccwPP4Q6.s:135    .text:00000074 $d
     /tmp/ccwPP4Q6.s:141    .text:00000084 $t
     /tmp/ccwPP4Q6.s:331    .text:00000204 $d
     /tmp/ccwPP4Q6.s:347    .text:00000230 $t
     /tmp/ccwPP4Q6.s:352    .text:00000230 batteryAdcToVoltage
     /tmp/ccwPP4Q6.s:407    .text:00000288 $d
     /tmp/ccwPP4Q6.s:413    .text:00000294 $t
     /tmp/ccwPP4Q6.s:418    .text:00000294 batteryInit
     /tmp/ccwPP4Q6.s:519    .text:00000330 $d
     /tmp/ccwPP4Q6.s:525    .text:0000033c $t
     /tmp/ccwPP4Q6.s:529    .text:0000033c alignSensors
     /tmp/ccwPP4Q6.s:632    .text:000003ec $d
     /tmp/ccwPP4Q6.s:636    .text:000003f0 $t
     /tmp/ccwPP4Q6.s:640    .text:000003f0 ACC_Common
     /tmp/ccwPP4Q6.s:826    .text:0000054c $d
     /tmp/ccwPP4Q6.s:2443   .bss:0000013c a.9085
     /tmp/ccwPP4Q6.s:2446   .bss:00000148 accZero_saved.9091
     /tmp/ccwPP4Q6.s:2449   .bss:00000150 angleTrim_saved.9092
     /tmp/ccwPP4Q6.s:838    .text:00000574 $t
     /tmp/ccwPP4Q6.s:1037   .text:00000708 $d
     /tmp/ccwPP4Q6.s:2452   .bss:00000154 b.9090
     /tmp/ccwPP4Q6.s:1053   .text:0000073c $t
     /tmp/ccwPP4Q6.s:1058   .text:0000073c ACC_getADC
     /tmp/ccwPP4Q6.s:1101   .text:0000076c $d
     /tmp/ccwPP4Q6.s:1107   .text:00000778 $t
     /tmp/ccwPP4Q6.s:1112   .text:00000778 Baro_Common
     /tmp/ccwPP4Q6.s:1183   .text:000007e0 $d
     /tmp/ccwPP4Q6.s:2437   .bss:00000078 baroHistIdx.9103
     /tmp/ccwPP4Q6.s:2440   .bss:0000007c baroHistTab.9102
     /tmp/ccwPP4Q6.s:1191   .text:000007f4 $t
     /tmp/ccwPP4Q6.s:1196   .text:000007f4 Baro_update
     /tmp/ccwPP4Q6.s:1295   .text:00000880 $d
     /tmp/ccwPP4Q6.s:2431   .bss:00000070 baroDeadline.9108
     /tmp/ccwPP4Q6.s:2434   .bss:00000074 state.9109
     /tmp/ccwPP4Q6.s:1304   .text:00000898 $t
     /tmp/ccwPP4Q6.s:1308   .text:00000898 devClear
     /tmp/ccwPP4Q6.s:1343   .text:000008b4 devPush
     /tmp/ccwPP4Q6.s:1460   .text:00000978 $d
     /tmp/ccwPP4Q6.s:1464   .text:0000097c $t
     /tmp/ccwPP4Q6.s:1468   .text:0000097c devVariance
     /tmp/ccwPP4Q6.s:1518   .text:000009b8 $d
     /tmp/ccwPP4Q6.s:1522   .text:000009bc $t
     /tmp/ccwPP4Q6.s:1526   .text:000009bc devStandardDeviation
     /tmp/ccwPP4Q6.s:1564   .text:000009e0 GYRO_Common
     /tmp/ccwPP4Q6.s:1837   .text:00000bfc $d
     /tmp/ccwPP4Q6.s:2422   .bss:00000020 g.9135
     /tmp/ccwPP4Q6.s:2425   .bss:0000002c var.9136
     /tmp/ccwPP4Q6.s:2428   .bss:00000068 previousGyroADC.9134
     /tmp/ccwPP4Q6.s:1850   .text:00000c24 $t
     /tmp/ccwPP4Q6.s:1855   .text:00000c24 Gyro_getADC
     /tmp/ccwPP4Q6.s:1898   .text:00000c54 $d
     /tmp/ccwPP4Q6.s:1908   .data:00000004 magCal
     /tmp/ccwPP4Q6.s:1913   .bss:00000007 magInit
     /tmp/ccwPP4Q6.s:1916   .text:00000c60 $t
     /tmp/ccwPP4Q6.s:1920   .text:00000c60 Mag_getRawADC
     /tmp/ccwPP4Q6.s:1946   .text:00000c78 $d
     /tmp/ccwPP4Q6.s:1950   .text:00000c7c $t
     /tmp/ccwPP4Q6.s:1955   .text:00000c7c Mag_init
     /tmp/ccwPP4Q6.s:1989   .text:00000ca0 $d
     /tmp/ccwPP4Q6.s:1996   .text:00000cac $t
     /tmp/ccwPP4Q6.s:2001   .text:00000cac Mag_getADC
     /tmp/ccwPP4Q6.s:2275   .text:00000ea8 $d
     /tmp/ccwPP4Q6.s:2410   .bss:00000008 t.9159
     /tmp/ccwPP4Q6.s:2413   .bss:0000000c tCal.9160
     /tmp/ccwPP4Q6.s:2416   .bss:00000010 magZeroTempMin.9161
     /tmp/ccwPP4Q6.s:2419   .bss:00000018 magZeroTempMax.9162
     /tmp/ccwPP4Q6.s:2289   .text:00000ed8 $t
     /tmp/ccwPP4Q6.s:2333   .text:00000f34 $d
     /tmp/ccwPP4Q6.s:2339   .text:00000f40 $t
     /tmp/ccwPP4Q6.s:2344   .text:00000f40 Sonar_init
     /tmp/ccwPP4Q6.s:2373   .text:00000f60 $d
     /tmp/ccwPP4Q6.s:2377   .text:00000f64 $t
     /tmp/ccwPP4Q6.s:2382   .text:00000f64 Sonar_update
     /tmp/ccwPP4Q6.s:2404   .text:00000f70 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.809c0ff785d6d6219236c5d51f444c16
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.newlib.h.8.e1d498e57c12962fc6d7be5061a6981a
                           .group:00000000 wm4.config.h.148.52fe83653334d06815a0c57b59a3e584
                           .group:00000000 wm4._ansi.h.23.95dee4059009fe3ab635a191bb73dc66
                           .group:00000000 wm4.stdlib.h.18.6f6153fd5cb89acd58c0f0ab1f77e147
                           .group:00000000 wm4.stddef.h.187.40b3a084f9bc2c020a9e00b9eabe9c14
                           .group:00000000 wm4._default_types.h.6.1dbd2e581fd590860c7c17f21d147e91
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:00000000 wm4.reent.h.16.58b23a9f0faf0e7f2dfe7e2d33154afd
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.55.22eafe60f8565d898cbb44515781114b
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.math.h.49.5da716593b937b9fb02bef6ed6537c13
                           .group:00000000 wm4.ctype.h.2.fecd14bb6f4e162ef31748cc97760e21
                           .group:00000000 wm4.string.h.8.ef946ad0bc9ad5c970c365dcd1fc4b0a
                           .group:00000000 wm4.stddef.h.235.d9f4f80b8c4429535175712282cda6a6
                           .group:00000000 wm4.string.h.86.d5c872ff52e2712c985b588a0ef39f3c
                           .group:00000000 wm4.stdio.h.27.f2ac352bab34f31f9f478442827b2ba6
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.stddef.h.40.b60a1c1ee3f272eef5327a730cbabca6
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.f2bfdfeee9f340633702c07fad9b5e01
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.63.1f4bc553faa62c5c69dd9cb47f9f1417
                           .group:00000000 wm4.stm32f10x.h.51.b859cb68ed44ee02c916b41cb8c68f1c
                           .group:00000000 wm4.core_cm3.h.25.119fe996be41b62fbd915b59177e39d1
                           .group:00000000 wm4.stm32f10x.h.522.9a9f642c8c562acb4a63ad5d933b7c01
                           .group:00000000 wm4.stm32f10x.h.8304.f7d8ad90959e99679b3257267c3aadfe
                           .group:00000000 wm4.stm32f10x_adc.h.83.4d35a50d598070ecea6f33bcef02c922
                           .group:00000000 wm4.stm32f10x_bkp.h.25.4622919f1e30efdad5eb44e12edd5513
                           .group:00000000 wm4.stm32f10x_can.h.25.48aab46fcce6d08400bf960b028e4698
                           .group:00000000 wm4.stm32f10x_cec.h.25.8f03450e7bbb704d96e7bc73ec0f66a7
                           .group:00000000 wm4.stm32f10x_dac.h.25.6e7f2924f39c60c10815105b99b8b446
                           .group:00000000 wm4.stm32f10x_dbgmcu.h.25.d3351200fc7f9c8615d1ae81d40db08a
                           .group:00000000 wm4.stm32f10x_dma.h.25.94e36204daa98cae5dcc70a10a9694d5
                           .group:00000000 wm4.stm32f10x_exti.h.25.b9064155c5c006b5154b39788c79001a
                           .group:00000000 wm4.stm32f10x_flash.h.25.4be61fcb02863962a1e006449d310650
                           .group:00000000 wm4.stm32f10x_fsmc.h.25.bca154da2699cdb6024c0c6c4fc5aa89
                           .group:00000000 wm4.stm32f10x_gpio.h.25.80c981af0e637567395034c576cfb3ce
                           .group:00000000 wm4.stm32f10x_i2c.h.25.7b6cbaea24c6f25f538f8516d1814cb2
                           .group:00000000 wm4.stm32f10x_iwdg.h.25.da9374ab9856795610487f312ccf3122
                           .group:00000000 wm4.stm32f10x_pwr.h.25.37ef75009f751ef5fe27910e0bf00a62
                           .group:00000000 wm4.stm32f10x_rcc.h.25.968bcf08d813e68e57c280a4da69fa5a
                           .group:00000000 wm4.stm32f10x_rtc.h.25.361142606ba98ddcd10369f321f6e636
                           .group:00000000 wm4.stm32f10x_sdio.h.25.1fb5280a7690ef99070096bf8c866b3a
                           .group:00000000 wm4.stm32f10x_spi.h.25.68b3d5ccfcf895f9fe505ce20c0c300f
                           .group:00000000 wm4.stm32f10x_tim.h.25.21c6ec062f1e74898cb96a57da276fec
                           .group:00000000 wm4.stm32f10x_usart.h.25.29629c699b65db3f3efd3561f66b0bf6
                           .group:00000000 wm4.stm32f10x_wwdg.h.25.dde12201d86b5aa9ecaafb5eccdc6549
                           .group:00000000 wm4.misc.h.25.068e106f368fa5369a681ef57c106f4b
                           .group:00000000 wm4.stdarg.h.31.fa591a4b1df9e413e9f5b8097f9ae89d
                           .group:00000000 wm4.printf.h.118.ab3672ee221610a07496c11f46394049
                           .group:00000000 wm4.board.h.22.3e17243136ce51e89ad1cec38a12dc6f
                           .group:00000000 wm4.drv_adc.h.3.0c1a2a90f0739aca31cc38e66ffab3f5
                           .group:00000000 wm4.drv_pwm.h.3.1f878ba1925c00079825df97e09db15d
                           .group:00000000 wm4.mw.h.4.b0e233e0e6ae9c4c07b142ad41413d4c

UNDEFINED SYMBOLS
__aeabi_i2f
__aeabi_fmul
__aeabi_fadd
mpu6050Detect
l3g4200dDetect
mpu3050Detect
failureMode
adxl345Detect
mma8452Detect
sensorsClear
ms5611Detect
bmp085Detect
sensors
hmc5883lDetect
mcfg
cfg
magneticDeclination
__aeabi_fdiv
__aeabi_f2uiz
adcGetChannel
delay
batteryCellCount
batteryWarningVoltage
writeEEPROM
feature
accADC
InflightcalibratingA
AccInflightCalibrationActive
AccInflightCalibrationMeasurementDone
toggleBeep
AccInflightCalibrationSavetoEEProm
baroPressure
baroPressureSum
currentTime
baroTemperature
__aeabi_fsub
sqrtf
__aeabi_fcmplt
blinkLED
gyroADC
gyroZero
hmc5883lRead
magADC
hmc5883lInit
__aeabi_f2iz
f
hcsr04_init
sensorsSet
sonarAlt
hcsr04_get_distance
